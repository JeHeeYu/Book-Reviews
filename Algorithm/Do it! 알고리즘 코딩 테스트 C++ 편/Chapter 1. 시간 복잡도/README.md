# 시간 복잡도 표기법 알아보기

## 시간 복잡도
알고리즘에서 시간 복잡도는 주어진 문제를 해결하기 위한 연산 횟수를 말한다.
<br>
일반적으로 C++에서는 <b>1억 번의 연산을 1초의 수행 시간</b>으로 예측할 수 있다.

<br>

시간 복잡도를 정의하는 유형은 총 3가지이다.
- 빅-오메가(Ω(n)) : 최선일 때(Best Case)의 연산 횟수를 나타낸 표기법
- 빅-세타(θ(n)) : 보통일 때(Avrage Case)의 연산 횟수를 나타낸 표기법
- 빅-오(O(n)) : 최악일 때(Worst Case)의 연산 횟수를 나타낸 표기법

### 코딩 테스트에서 사용해야 할 시간 복잡도 유형
코딩 테스트에서는 빅-오 표기법을 기준으로 수행 시간을 계산하는 것이 좋다.
<br>
실제 테스트에서는 1개의 케이스로만 합격 불합격 여부를 결정하지 않기 때문이다.
<br>
<br>
응시자가 작성한 프로그램으로 다양한 테스트 케이스를 수행해 모든 케이스를 통과해야만 합격으로 판단하므로, 최악일 때를 염두에 두어야 한다.
<br>
아래 이미지는 빅-오 표기법으로 푠현한 시간 복잡도 그래프로, 데이터 크기(N)의 증가에 따라 성능(수행 시간)이 다르다는 것을 알 수 있다.
<br>

![image](https://user-images.githubusercontent.com/87363461/229274521-451ef712-7f74-439b-a998-ff4dcd62b582.png)

<br>

## 시간 복잡도 활용하기

예를 들어, 아래와 같은 문제가 있다.

### [예제 문제](https://www.acmicpc.net/problem/2750)

<br>
<br>

이 문제는 시간제한이 2초이므로, 이 조건을 만족하기 위해 2억 번 이하의 연산 횟수로 문제를 해결해야 한다.
<br>
따라서 주어진 시간 제한과 데이터 크기를 바탕으로 어떤 정렬 알고리즘을 사용해야 할 것인지를 판단할 수 있다.
- 연산 횟수 = 알고리즘 시간 복잡도 n값에 데이터의 최대 크기를 대입하여 도출

<br>

이러한 연산 공식으로 판단할 수 있는데, 예를 들어 버블 정렬과 병합 정렬로 계산한다.
- 버블 정렬 : (1,000,000)^2 = 1,000,000,000,000 > 200,000,000 -> 부적합 알고리즘
- 병합 정렬 : 1,000,000,000log(2)(1,000,000) = 약 20,000,000 < 200,000,000 -> 적합 알고리즘

문제에 주어진 시간 제한이 2초이므로 연산 횟수 2억 번 안에 드는 답을 구하기 위해 버블 정렬이 아닌 병합 정렬을 사용해야 한다.

<br>
<br>

### 시간 복잡도를 바탕으로 코드 로직 개선
시간 복잡도는 작성한 코드의 비효율적 로직을 개선하는 바탕으로도 사용할 수 있다.
<br>
이 부분을 활용하기 위해 먼저 코드의 시간 복잡도를 도출할 수 있어야 하는데, 도출 방법은 2가지가 있다.
- 상수는 시간 복잡도 계산에서 제외
- 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 됨

예를 들어 아래와 같은 코드로 반복문이 1개인 것과 3개인 것 두 가지의 코드가 있다.
```
// 예제 1 : 연산 횟수 = N

#include <iostream>

using namespace std;

int main()
{
    int N = 1000;
    int cnt = 1;
    
    for(int i = 0; i < N; i++) {
        cout << "연산 횟수:" << cnt++ << "\n";
    }

    return 0;
}

```

```
// 예제 2 : 연산 횟수 = 3N

#include <iostream>

using namespace std;

int main()
{
    int N = 1000;
    int cnt = 1;
    
    for(int i = 0; i < N; i++) {
        cout << "연산 횟수:" << cnt++ << "\n";
    }
    
    for(int i = 0; i < N; i++) {
        cout << "연산 횟수:" << cnt++ << "\n";
    }
    
    for(int i = 0; i < N; i++) {
        cout << "연산 횟수:" << cnt++ << "\n";
    }

    return 0;
}

```

두 예제 코드의 연산 횟수는 3배가 차이가 나므로 언뜻 보면 큰 차이일 수 있다.
<br>
<b>하지만 코딩테스트에서는 일반적으로 상수를 무시하므로 두 코드 모두 시간 복잡도는 O(n)</b> 으로 같다.
<br>
<br>
또 다음 예제인 아래 코드를 확인한다.
```
// 예제 3 : 연산 횟수 = N^2

#include <iostream>

using namespace std;

int main()
{
    int N = 1000;
    int cnt = 1;
    
    for(int i = 0; i < N; i++) {
        for(int j = 0; j < N; j++) {
            cout << "연산 횟수:" << cnt++ << "\n";
        }
    }

    return 0;
}

```

시간 복잡도는 <b>가장 많이 중첩된 반복문을 기준으로 도출하므로,</b> 이 코드에서는 이중 for문이 전체 코드의 시간 복잡도 기준이 된다.
<br>
만약 일반 for문이 10개가 있다고 하더라도 도출 기준 2번에 따라 시간 복잡도의 변화 없이 N^2로 유지된다.
<br>
<br>
이렇게 자신이 작성한 코드의 시간 복잡도를 도출할 수 있다면 실제 코딩 테스트에서 시간 초과가 발생했을 경우 문제를 해결할 수 있다.
