# 스택과 큐 정리 내용

## 스택과 큐의 핵심 이론


### 스택(Stack)
스택은 삽입과 삭제 연산이 후입선출(LIFO, Last-In First-Out)으로 이루어지는 자료구조이다.
<br>
후입선출은 삽입과 삭제가 한 쪽에서만 일어나는 특징이 있다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/d5b64262-7ff8-467d-9193-4a2ead7e9e2b)



<br>

위 그림을 보면 새 값이 스택에 들어가면 top이 새 값을 가리킨다.
<br>
스택에서 값을 빼낼 때 pop은 top이 가리키는 값을 스택에서 빼게 되어 있으므로 결과적으로는 가장 마지막에 넣었던 값이 나오게 된다.

### 스택 용어

- 위치
  - top : 삽입과 삭제가 일어나는 위치
- 연산
  - push : top 위치에 새로운 데이터를 삽입하는 연산
  - pop : top 위치에 현재 있는 데이터를 삭제하고 확인하는 연산
  - top : top 위치에 현재 있는 데이터를 확인하는 연산


<br>

### 큐(Queue)

큐는 삽입과 삭제 연산이 선입선출(FIFO, First-In First-Out)로 이루어지는 자료구조이다.
<br>
스택과 다르게 먼저 들어온 데이터가 먼저 나가며 삽입과 삭제가 양방향에서 이루어진다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/45aafaf5-4b4e-48d1-828a-a0c3aa30f386)


<br>

### 큐 용어
- 위치
  - back : 큐에서 가장 끝 데이터를 가리키는 명령어
  - front : 큐에서 가장 앞의 데이터를 가리키는 영역
- 연산
  - push : back 부분에 새로운 데이터를 삽입하는 연산
  - pop : front 부분에 있는 데이터를 삭제하고 확인하는 연산


<br>

## 문제 001 스택으로 수열 만들기 (실버 2, 1874)

[문제 링크](https://www.acmicpc.net/problem/1874)


### 1. 문제 분석하기
스택의 원리를 정확하게 알고 있는지를 묻는 문제이므로, pop, push와 후입선출 개념을 알고 있다면 쉽게 풀 수 있다.
<br>
스택에 넣는 값은 오름차순 정렬이어야 한다는 것을 유념해야 한다.

### 2. 손으로 풀어 보기
이 문제는 1부터 자연수를 증가시키면서 입력으로 주어진 숫자와 비교하여 증가시킨 자연수를 스택에 추가하거나 빼는 방식으로 풀면 된다.
<br>
스택 연산은 다음 2가지 방법으로 수행한다.

1. 현재 수열 값 >= 자연수
현재 수열 값이 자연수보다 크거나 같을 때까지 자연수를 1씩 증가시키며 자연수를 스택에 push한다.
<br>
그리고 push가 끝나면 수열을 출력하기 위해 마지막 1회만 pop 한다.
<br>
<br>
예를 들어 현재 수열 값이 4면 스택에는 1, 2, 3, 4를 push하고 마지막에 1회만 pop하여 4를 출력한 뒤 조건문을 빠져 나온다.
<br>
여기서 자연수는 5가 된다.

<br>

2. 현재 수열 값 < 자연수
현재 수열 값보다 자연수가 크다면 pop으로 스택에 있는 값을 꺼낸다.
<br>
꺼낸 값이 현재 수열 값이거나 아닐 수 있다.
<br>
이때 만약 아니라면 후입선출 원리에 따라 수열을 표현할 수 없으므로 NO를 출력하고 문제를 종료, 현재 수열 값이라면 그대로 조건문을 빠져나온다.

<br>
<br>
예를 들어, 자연수 5, 현재 수열 값은 3이므로 스택에서 3을 꺼낸다.
<br>
현재 수열 값과 스택에서 꺼낸 값은 같으므로 계속해서 스택 연산을 수행할 수 있다.

<br>
<br>
아래 그림은 전체 과정을 나타내는 그림이다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/b93a4887-4dd2-45f3-9a3d-4f83dd0e2b3b)


<br>


### 3. 슈도코드 작성하기

```
N(수열 개수)
A(수열 저장 배열)
resultV(결과 저장 배열)
수열 저장 배열에 데이터 저장

for(N만큼 반복) {
    if(현재 수열 값 >= 오름차순 자연수) {
        while(값이 같아질 때까지) {
            push()
            (+)저장
        }
        마지막 값을 pop()
        (-) 저장
    }
    else { // 현재 수열 값 < 오름차순 자연수
        스택의 가장 위의 값 pop()
        if(스택 pop 결괏값 > 수열의 수) {
             NO 출력
        }
        else {
            (-) 저장
        }
    }
}

if(-값을 출력한 적이 없으면) {
    저장한 값 출력
}
```


<br>

### 4. 코드 구현하기

### [예제 코드](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/Do%20it!%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20C%2B%2B%20%ED%8E%B8/Chapter%202.%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D%EA%B3%BC%20%ED%81%90/1874.cpp)

<br>

## 문제 012 오큰수 구하기 (골드 4, 17298)

[문제 링크](https://www.acmicpc.net/problem/17298)



<br>

### 1. 문제 분석하기
N의 최대 크기가 1,000,000 이므로 반복문으로 오큰수를 찾으면 제한 시간을 초과한다.
<br>
그러므로 스택에 아이디어를 추가해 이 문제를 풀어야 한다.
<br>

```
// 스택에 추가할 아이디어

- 스택에 새로 들어오는 수가 top에 존재하는 수보다 크면 그 수는 오큰수가 된다.
- 오큰수를 구한 후 수열에서 오큰수가 존재하지 않는 숫자에 -1을 출력해야 한다.
```

<br>

### 2. 손으로 풀어보기
먼저 정답 배열에 값을 모두 채운 후 출력하면 문제가 요구하는 답을 구할 수 있다.


```
// 문제 푸는 순서

1. 스택이 채워져 있고 A[index] > A[top]인 경우 pop한 인덱스를 이용하여 정답 수열에 오큰수를 저장한다. pop은 조건을 만족하는 동안 계속 반복한다.
2. 현재 인덱스를 스택에 push하고 다음 인덱스로 넘어간다.
3. 1 ~ 2 과정을 수열 길이만큼 반복한 다음 현재 스택에 남아 있는 인덱스에 -1을 저장한다.
```

<br>

예를 들어, 예제 입력 1의 경우다.
<br>
pop은 정답 배열에 값을 추가하는 것이고, push는 다음 인덱스를 본다고 생각하면 된다.

<br>


![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/88177df0-06f3-426d-92db-995197e0210e)

<br>

처음에는 스택이 비어 있으므로 1번 과정이 2번 과정을 진행한다.
<br>
이후 인덱스 0을 push하고 다음 인덱스로 넘어간다.
<br>
<br>
A[1]은 5이고, A[top]은 3이므로 스택에서 pop을 수행하고 Result[0]에 오큰수 5를 저장한다.
<br>
<br>
1회 반복으로 스택이 비었으므로 pop은 더 진행하지 않는다.
<br>
<br>
인덱스 1을 push하고 다음 인덱스로 넘어간다.
<br>
<br>
A[2]는 2이고, A[top]은 5이므로 과정 2를 진행하여 push하고 다음 인덱스로 넘어간다.
<br>
<br>
이 과정을 수열의 길이만큼 반복 후 스택에 남아 있는 index에 -1을 저장하면 정답 배열을 완성할 수 있다.



<br>


### 3. 슈도코드 작성하기

```
N(수열 개수), A(수열 배열), ans(정답 배열)
수열 배열 채우기
최초 스택 초기화(0 push)

for(N만큼 반복) {
    while(스택이 비지 않고 현재 수열값이 top에 해당하는 수열보다 클 때까지) {
        정답 배열에 오큰수를 현재 수열로 저장
        스택 pop 수행
    }
    현재 수열을 스택에 push
}

while(스택이 빌 때까지) {
    스택에 있는 인덱스에 대하여 정답 배열에 -1 저장
    스택 pop 수행
}

정답 배열 출력
```

<br>

### 4. 코드 구현하기

### [예제 코드](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/Do%20it!%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20C%2B%2B%20%ED%8E%B8/Chapter%202.%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D%EA%B3%BC%20%ED%81%90/17298.cpp)



<br>


## 문제 013 카드2 (실버 4, 2164)

[문제 링크](https://www.acmicpc.net/problem/2164)


<br>


### 1. 문제 분석하기
큐를 잘 이해하고 있는지 확인하는 문제로, 가장 위의 카드를 가장 아래에 있는 카드 밑으로 옮기는 동작은 큐의 선입선출 성질을 이용하면 쉽게 구현할 수 있다.

<br>
<br>

카드의 개수가 최대 500,000 이므로 시간 복잡도의 제약도 크지 않다.

<br>


### 2. 손으로 풀어 보기

다음 3가지의 순서로 문제를 풀 수 있다.

1. pop을 수행하면 맨 앞의 카드를 버린다.
2. 1번 과정에 이어 바로 pop -> push를 수행해 맨 앞에 있는 카드를 가장 아래로 옮긴다.
3. 큐의 크기가 1이 될 때까지 과정 1 ~ 2를 반복한 후 큐에 남은 원소를 출력한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/dd557757-b4cc-45dd-8360-92299d2d9b03)


<br>

### 3. 슈도코드 작성하기

```
N(카드 개수)
myQueue(카드 저장 큐)

for(카드 개수만큼 반복) {
    큐에 카드 저장
}

while(카드가 1장 남을 때까지) {
    맨 위의 카드를 버림
    맨 위의 카드를 제일 아래 카드로 밑으 이동
}

마지막으로 남은 카드 출력
```

<br>

### 4. 코드 구현하기

### [예제 코드](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/Do%20it!%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20C%2B%2B%20%ED%8E%B8/Chapter%202.%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D%EA%B3%BC%20%ED%81%90/2164.cpp)



<br>


## 문제 014 절댓값 힙 (실버 1, 11286)

[문제 링크](https://www.acmicpc.net/problem/11286)

<br>

### 1. 문제 분석하기

N의 최대 범위가 100,000으로 O(nlogn) 시간 복잡도를 가진 알고리즘으로 문제를 풀 수 있다.
<br>
데이터가 새로 삽입될 때마다 절댓값과 관련된 정렬이 필요하므로 우선순위 큐로 문제를 쉽게 해결할 수 있다.
<br>
<br>
단, 이 문제는 절댓값 정렬이 필요하므로 우선순위 큐의 정렬 기준을 직접 정의해야 한다.
<br>
예제의 절댓값이 같을 때는 음수를 우선하여 출력해야 하는 사실을 기억해야 한다.

<br>


### 2. 손으로 풀어 보기

문제 푸는 순서는 2가지이다.

1. x = 0
큐가 비어 있을 때는 0을 출력하고 비어 있지 않을 때는 절댓값이 최소인 값을 출력한다.
<br>
단, 절댓값이 같다면 음수를 우선하여 출력한다.

2. x = 1
큐에 새로운 값을 추가하고 우선순위 큐 정렬 기준으로 자동 정렬한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/d6ede818-e930-43ca-8e67-ff3096bdb123)


<br>

### 3. 슈도코드 작성하기

```
N(질의 요청 개수)
MyQueue(데이터 저장 우선순위 큐)
절댓값 기준으로 정렬되도록 설정
단, 절댓값이 같다면 음수 우선 정렬

for(N만큼 반복) {
    요청이 0일 때 : 큐가 비었으면 0 출력, 아니면 큐의 top 출력하고 pop
    요청이 1일 때 : 새로운 데이터를 우선순위 큐에 push
}
```

<br>


### 4. 코드 구현하기

### [예제 코드](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/Do%20it!%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20C%2B%2B%20%ED%8E%B8/Chapter%202.%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D%EA%B3%BC%20%ED%81%90/11286.cpp)
