# 슬라이딩 윈도우 정리 내용


## 문제 009 DNA 비밀번호 (실버 2, 12891)

[문제 링크](https://www.acmicpc.net/problem/12891)

<br>

### 1. 문제 분석하기
P와 S의 길이가 1,000,000으로 매우 크기 때문에 O(n)의 시간 복잡도 알고리즘으로 문제를 해결해야 한다.
<br>
이때 부분 문자열의 길이가 P이므로 슬라이딩 윈도우의 개념을 이용하면 문제를 쉽게 해결할 수 있다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/e851563f-a9b1-4a1f-8923-e0ac9198d012)



<br>

위 그림을 보면 길이가 P인 윈도우를 지정하여 배열 S의 시작점에 놓는다.
<br>
그 후 윈도우를 오른쪽으로 밀면서 윈도우에 잡힌 값들이 조건에 맞는지 탐색한다.
<br>
<br>
이런 동작이 마치 창틀에 놓고 이동하는 모양 같아 슬라이딩 윈도우라는 이름이 지어진 것이다.
<br>
<br>
배열 S의 길이만큼만 탐색을 진행하면 되므로 O(n)의 시간 복잡도로 문제를 해결할 수 있다.

<br>


### 2. 손으로 풀어 보기

1. 배열 S와 비밀번호 체크 배열을 저장한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/59fa2b30-f15e-4156-9d8a-ff6904587764)


<br>

2. 윈도우에 포함된 문자로 현재 상태 배열을 만든 후, 다음 현재 상태 배열과 비밀번호 체크 배열을 비교하여 유효 비밀번호인지 판단한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/44f5eef8-86b7-475c-b54a-2f43c9680a10)


<br>

3. 윈도우를 한 칸씩 이동하여 현재 상태 배열을 업데이트한다.<br>현재 상태 배열을 업데이트한 이후 비밀번호 체크 배열과 비교하여 비밀번호의 유효성을 판단한다.<br>현재 상태 배열을 업데이트할 때는 빠지는 문자열, 신규 문자열만 보고 업데이트하는 방식으로 진행한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/049c408f-441f-4887-b0a3-679fa30644b0)


<br>

위 그림의 경우 윈도우를 한 칸 이동하여 C가 빠지고, G가 추가되어 현재 상태 배열을 1, 2, 2, 3에서 1, 1, 3, 3으로 업데이트 한 것이다.
<br>
비밀번호 체크 배열과 비교했을 때 A가 2보다 작으니 유효 비밀번호는 아니다.

<br>

### 3. 슈도코드 작성하기

```
checkArr(비밀번호 상태 체크 배열)
myArr(현재 상태 배열)
checkSecret(몇 개의 문자에 대한 개수를 충족했는지 판단하는 변수)
S(문자열 크기), P(부분 문자열 크기)
A(문자열 데이터)
P 범위(0 ~ P - 1)만큼 배열 S에 적용하고 유효한 비밀번호인지 판단하기

for(i를 P에서 S까지 반복) {
    j 선언(i - P)
    // 한 칸씩 이동하면서 제거되는 문자열과 새로 들어오는 문자열에 대해 처리
    Add(A[i])
    Remove(A[j])
    현재 부분 문자열이 유효한 비밀번호인지(checkSecret == 4) 판단하여 결괏값 업데이트
}

결괏값 출력

// 별도 함수
Add(문자 더하기 함수) {
    새로 들어온 문자에 대해 myArr 업데이트 및 checkSecret값 변경
}

Remove(문자 빼기 함수) {
    제거되는 문자에 대해 myArr 업데이트 및 checkSecret값 변경
}
```

### 4. 코드 구현하기

[예제 코드](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/Do%20it!%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20C%2B%2B%20%ED%8E%B8/Chapter%202.%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9%20%EC%9C%88%EB%8F%84%EC%9A%B0/12891.cpp)


<br>


## 문제 010 최솟값 찾기 1 (플래티넘 5, 11003)

[문제 링크](https://www.acmicpc.net/problem/11003)

<br>

### 1. 문제 분석하기
일정 범위 안에서 최솟값을 구하는 문제이므로 슬라이딩 윈도우와 정렬 알고리즘을 사용할 수 있다.
<br>
윈도우의 크기는 문제에서 최솟값을 구하는 범위가 i - L + 1부터 i까지 이므로 L로 생각하면 된다.
<br>
<br>
여기서 정렬은 사용할 수 없는데, 일반적으로 정렬은 O(nlogn)의 시간 복잡도를 가진다.
<br>
N과 L의 최대 범위가 5,000,000 이므로 이 문제에서는 정렬을 사용할 수 없고, O(n) 시간 복잡도로 해결해야 한다.
<br>
<br>
여기서는 덱 구조를 사용해서 해결한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/85d671d8-c15c-42d2-b3c9-882fe2a04fcb)


<br>

### 2. 손으로 풀어 보기

1. 덱에서는 (인덱스, 숫자) 형태의 노드를 클래스로 구현하여 저장한다.

<br>


![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/1aeb8f33-4a24-4777-8501-4382442547e3)

<br>

2. 이 상태에서 새 노드(3, 2)가 덱에 저장되면 여기부터 기존 덱에 있던 노드가 제거된다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/a033b8fe-60b0-4e1c-8125-46ac2c1cc9b2)


<br>

새 노드(3, 2)가 저장될 때 덱 뒤에서부터 비교를 시작한다.
<br>
(2, 5)는 (3, 2)보다 숫자가 크므로 (2, 5)는 덱에서 제거(pop_back)한다.
<br>
<br>
이어서 (1, 1)은 (3, 2)보다 숫자가 작으므로 탐색을 멈추고 (3, 2)를 덱에 저장(push_back_한다.
<br>
<br>
결과를 보면 (2, 5)가 덱에서 제거되어 덱에는 (1, 1), (3, 2) 순서로 노드가 오름차순 정렬되어 있다.
<br>
<br>
이것이 바로 덱을 이용하여 정렬 효과를 보는 방법이다.
<br>
정리를 끝마친 상태의 덱을 보면 인덱스의 범위는 1 ~ 3으로 슬라이딩 윈도우의 크기인 K(3)과 같다.
<br>
<br>
이후 최솟값 찾기는 간단한데, 바로 덱 처음에 있는 (1, 1)노드와 같은 숫잣값이다.

<br>

3. 계속해서 새 노드를 추가한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/41d89fde-373c-470c-935b-823eba9fd33d)

<br>

새 노드(4, 3)은 덱 뒤에서부터 비교했을 때 (3, 2)보다 숫자가 크므로 덱에 저장된다.
<br>
여기서 인덱스 범위에 의해 덱 앞쪽의 노드가 제거된다.
<br>
<br>
(1, 1), (3, 2), (4, 3)의 인덱스 범위는 1 ~ 4이므로 윈도우 범위인 3을 벗어난다.
<br>
최솟값은 윈도우 범위 내에서 찾기로 했으므로 (1, 1)은 덱에서 제거해야 한다.
<br>
<br>
제거가 끝난 이후 최솟값을 출력하면 2이다.

<br>

4. 다시 정리하면 숫자 비교, 윈도우 범위 계산이 끝난 덱에서 맨 앞에 있는 노드의 숫자를 출력하기만 하면 정답이 된다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/df8d3d51-afa7-4676-919e-b62ee7e02d59)


<br>

정답을 출력하는 과정을 정리하면 아래와 같다.

<br>

1. 최초 (1, 1)이 덱에 추가되면 비교 대상이 없고, 범위도 만족하므로 바로 1을 출력한다.
2. (2, 5)는 (1, 1)과 숫자를 비교했을 때 더 크므로 탐색을 멈추고 덱에 추가한다.<br>인덱스 범위가 1 ~ 2여서 윈도우 범위를 만족하므로 다시 1을 출력한다.
3. (3, 2)는 (2, 5)와 숫자를 비교했을 때 더 작으므로 (2, 5)를 덱에서 제거한다.<br>(1, 1)은 여전히 (3, 2)보다 숫자가 작으므로 탐색을 멈추고 (3, 2)를 덱에 저장한다. <br> 덱의 상태는 (1, 1), (3, 2)가 되고, 인덱스 범위 1 ~ 3 역시 윈도우 범위를 만족하므로 다시 1을 출력한다.

<br>

### 3. 슈도코드 작성하기

```
N(데이터 개수) L(최소값을 구하는 범위)
Node 타입 선언(int, int)
deque<Node> mydeque(데이터를 담을 덱 자료구조)

for(N만큼 반복) {
    now(현재 데이터)
    덱의 마지막 위치에서부터 now보다 큰 값은 덱에서 제거
    덱의 마지막 위치에 now값 저장
    덱의 첫 번째 위치에서부터 L의 범위를 벗어난 값(now index - L <= index)을 덱에서 제거
    덱의 첫 번째 데이터 출력
}
```


<br>


### 4. 코드 구현하기

### [예제 코드](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/Do%20it!%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20C%2B%2B%20%ED%8E%B8/Chapter%202.%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9%20%EC%9C%88%EB%8F%84%EC%9A%B0/11003.cpp)
