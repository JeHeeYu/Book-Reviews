# 투 포인터 정리 내용

## 문제 006 수들의 합 5 (실버5, 2018)

[문제 링크](https://www.acmicpc.net/problem/2018)

### 1. 문제 분석하기
이 문제는 시간 복잡도 분석으로 사용할 알고리즘의 범위부터 줄여야 한다.
<br>
우선 문제에 주어진 시간 제한은 2초이며 N의 최댓값은 10,000,000 으로 매우 크게 잡혀있다.
<br>
<br>
이런 상황에서는 O(nlogn)의 시간 복잡도 알고리즘을 사용하면 제한 시간을 초과하므로 O(n)의 시간 복잡도 알고리즘을 사용해야 한다.
<br>
<br>
이런 경우에서 자주 사용하는 알고리즘이 투 포인터 알고리즘이다.
<br>
연속된 자연수의 합을 구하는 것이 문제이므로 시작 인덱스와 종료 인덱스를 지정하여 연속된 수를 표현한다.

### 2. 손으로 풀어 보기

1. 입력받은 값을 N에 저장한 후 코드에서 사용할 변수를 모두 초기화한다.<br> 결과 변수 count를 1로 초기화하는 이유는 N이 15일 때 숫자 15만 뽑는 경우의 수를 미리 넣고 초기화했기 때문이다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/f0364791-5701-4381-8d29-86bd86376c55)


<br>


2. 다음에서 보이는 투 포인터 이동 원칙을 활용해 배열의 끝까지 탐색하면서 합이 N이 될 경우의 수를 구한다.<br>start_index를 오른쪽으로 한 칸 이동하는 것은 연속된 자연수에서 왼쪽 값을 삭제하는 것과 효과가 같다.<br>end_index를 오른쪽으로 한 칸 이동하는 것은 연속된 자연수의 범위를 한 칸 더 확장하는 의미이다.<br>sum과 N이 같을 때는 경우의 수를 1 증가시키고, end_index를 오른쪽으로 이동시킨다.

```
// 투 포인터 이동 원칙

sum > N : sum = sum - start_index; start_index++;
sum < N : end_index++; sum = sum + end_index;
sum == N : end_index++; sum = sum + end_index; count++;
```

3. 2단계를 end_index가 N이 될 때까지 반복하되, 포인터가 이동할 때마다 현재의 총합과 N을 비교해 값이 같으면 count를 1만큼 증가시키면 된다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/4cdab8f6-e199-4d7b-bcda-a9ddf7f5f1e3)


<br>










