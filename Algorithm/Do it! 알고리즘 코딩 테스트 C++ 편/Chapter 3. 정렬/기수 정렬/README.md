# 기수 정렬 정리 내용

## 기수 정렬(Radix Sort)
기수 정렬은 값을 비교하지 않는 특이한 정렬이다.
<br>
기수 정렬은 값을 놓고 비교할 자릿수를 정한 다음 해당 자릿수만 비교한다.
<br>
<br>
기수 정렬의 시간 복잡도는 O(kn)으로, 여기서 k는 데이터의 자릿수를 말한다.

<br>

## 기수 정렬의 핵심 이론
기수 정렬은 10개의 큐를 이용한다.
<br>
그리고 각 큐는 값의 자릿수를 대표한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/ac0b336c-58e5-4491-a72d-d1372f3594e8)


<br>

위 그림을 보면 원본 배열은 16, 80, 18, 77, 03, 24, 88, 23이다.
<br>
그러면 일의 자릿수 기준으로 배열 원소를 큐에 집어넣는다.
<br>
<br>
그 후 0번째 큐부터 9번째 큐까지 pop을 진행한다.
<br>
그 결과 80, 03, 23, 24, 16, 77, 18, 88이 만들어진다.
<br>
<br>
이어서 십의 자릿수를 기준으로 같은 과정을 진행한다.
<br>
마지막 자릿수를 기준으로 정렬할 때까지 앞의 과정을 반복한다.
<br>
<br>
기수 정렬은 시간 복잡도가 가장 짧은 정렬로, 정렬해야 하는 데이터의 개수가 너무 많을 경우 유용하다.

<br>


## 문제 022 수 정렬하기 3 (브론즈 1, 10989)

[문제 링크](https://www.acmicpc.net/problem/10989)

<br>

### 1. 문제 분석하기
이 문제는 N의 최대 개수가 10,000,000 으로 매우 크기 때문에 O(nlogn)보다 더 빠른 알고리즘이 필요하다.
<br>
문제에서 주어지는 숫자의 크기가 10,000 이하라는 것을 바탕으로 기수 정렬과 함께 많이 사용하는 계수 절열(Counting Sort)를 사용하여 문제를 해결한다.

<br>

### 2. 손으로 풀어 보기
숫자 크기가 10,000 이하이므로 10,001 크기의 배열을 선언한다.
<br>
이후 문제에서 입력하는 수를 차례대로 받아 수의 값을 배열의 인덱스 값으로 판단하고 해당 인덱스에 해당하는 값을 1 증가하여 준다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/933b7bfc-cd46-40c4-97fb-20ed48a4bba7)



<br>


이어서 배열을 처음부터 끝까지 탐색하면서 값이 0이 아닐 경우 해당 값이 있는 index를 값만큼 반복하여 출력한다.

<br>


![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/4e154930-d58c-40a5-9321-a690dfeb69ef)



<br>


### 3. 슈도코드 작성하기

```
N(정렬할 수 개수)
count(계수 정렬 배열)

for(N만큼 반복) {
    count 배열에 현재 수에 해당하는 index의 값 1 증가시키기
}

for(i는 0 ~ 10000까지) {
    // i가 기존 input에 있는 수였다면
    if(count[i]의 값이 0이 아니면) { 
        해당 값만큼 i를 반복하여 출력
    }
}
```





