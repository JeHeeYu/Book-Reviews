# 깊이 우선 탐색 정리 내용

## 깊이 우선 탐색(DFS, Depth-First Search)
깊이 우선 탐색은 그래프 완전 탐색 기법 중 하나이다.
<br>
깊이 우선 탐색은 그래프의 시작 노드에서 출발하여 탐색할 한쪽 분기를 정하여 최대 깊이까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘이다.
<br>
<br>
다음 표는 깊이 우선 탐색의 기능, 특징, 시간 복잡도를 표로 정리한 것이다.
<br>
표의 시간 복잡도는 노드 개수를 V, 에지 개수를 E로 표시했다.

|기능|특징|시간 복잡도(노드 수 : V / 에지 수 : E)|
|:---:|:---|:---:|
|그래프 완전 탐색|- 재귀 함수로 구현<br>- 스택 자료구조 이용|O(V + E)|


<br>

깊이 우선 탐색은 실제 구현 시 재귀 함수를 이용하므로 스택 오버플로(Stack Overflow)에 유의해야 한다.
<br>
깊이 우선 탐색을 이용하여 풀 수 있는 문제는 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬 등이 있다.

<br>

## 깊이 우선 탐색의 핵심 이론
DFS는 한 번 방문한 노드를 다시 방문하면 안 되므로 노드 방문 여부를 체크할 배열이 필요하며, 그래프는 인접 리스트로 표현한다.

### 1. DFS를 시작할 노드를 정한 후 사용할 자료구조 초기화
DFS를 위해 필요한 초기 작업은 인접 리스트로 그래프 표현, 방문 배열 초기화, 시작 노드 스택에 삽입이다.
<br>
스택에 시작 노드를 1로 삽입할 때 해당 위치의 방문 배열을 체크하면 T, F, F, F, F, F가 된다.

<br>


![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/2c43c319-6713-4d9e-a67d-fd5faeb3ee32)


<br>


### 2. 스택에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 스택에 삽입하기
이제 pop을 수행하여 노드를 꺼낸다.
<br>
꺼낸 노드를 탐색 순서에 기입하고 인접 리스트의 인접 노드를 스택에 삽입하며 방문 배열을 체크한다.
<br>
<br>
방문 배열은 T, T, T, F, F, F가 된다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/d083a556-2b92-49a1-8eb2-1496b99da125)


<br>

### 3. 스택 자료구조에 값이 없을 때까지 반복하기
앞선 과정을 스택 자료구조에 값이 없을 때까지 반복한다.
<br>
이미 다녀간 노드는 방문 배열을 바탕으로 재삽입하지 않는 것이 핵심이다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/f5569ca4-5f2d-47ed-80a5-5f47d262f22f)


<br>

이어서 스택에서 3을 꺼내며 탐색 순서에 기록하고 인접 노드 4를 스택에 삽입하며 방문 배열에 체크한다.
<br>
4를 꺼내며 탐색 순서에 기록하고 6을 삽입하며 방문 배열에 체크한다.
<br>
<br>
6을 꺼내며 탐색 순서에 기록하고 6과 인접한 노드는 없으므로 추가 삽입은 없다.
<br>
<br>
계속해서 스택에서 2를 꺼내며 탐색 순서에 기록하고 2와 인접한 5, 6을 삽입하기 위해 확인한다.
<br>
이때 6은 방문 배열에 T로 체크되어 있으므로 5만 삽입한다.
<br>
이 과정을 스택이 빌 때까지 진행한다.

<br>

## 문제 023. 연결 요소의 개수 (실버 2, 11724)

[문제 링크](https://www.acmicpc.net/problem/11724)

<br>


### 1. 문제 분석하기
노드의 최대 개수가 1,000이므로 시간 복잡도 N^2 이하의 알고리즘을 모두 사용할 수 있다.
<br>
연결 요소는 에지로 연결된 노드의 집합이며, 한 번의 DFS가 끝날 때까지 탐색한 모든 노드의 집합을 하나의 연결 요소로 판단할 수 있다.

<br>


### 2. 손으로 풀어 보기

1. 그래프를 인접 리스트로 저장하고 방문 배열을 초기화 한다.<br>방향이 없는 그래프이기 때문에 양쪽으로 에지를 모두 저장한다.

<br>


![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/7100a51b-87e0-4871-b1db-6f7605dbc926)



<br>

2. 임의의 시작점에서 DFS를 수행한다.<br>현재의 경우 1을 시작점으로 정했으며 탐색을 마친 이후 방문한 곳은 1, 2, 5가 된다.

<br>

  
![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/d8316caf-9f8c-4ee3-aded-2ebf73689cab)


<br>


3. 아직 방문하지 않은 노드가 있으므로 시작점을 다시 정해 탐색을 진행한다.<br>현재의 경우 3, 4, 6 순서로 탐색을 마쳤다.<br>모든 노드를 방문했으니 전체 탐색을 종료한다.

<br>


![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/ba5f1dda-f5e7-4da9-b9e7-5b371896a7da)


<br>


4. 1 ~ 3 과정을 통해 총 2번의 DFS가 진행되었다는 것을 알 수 있다.<br>즉, 연결 요소 개수는 2개이다.

<br>


### 3. 슈도코드 작성하기

```
N(노드 개수), M(에지 개수)
A(그래프 데이터 저장 인접 리스트) // 이차원 벡터 형태
visited(방문 기록 저장 배열)
벡터 A 크기 N + 1로 재설정

for(M의 개수만큼 반복) {
    인접 리스트 A에 그래프 데이터 저장
}

for(N의 개수만큼 반복) {
    if(방문하지 않은 노드가 있으면) {
        연결 요소 개수++
        DFS 실행
    }
}

연결 요소 개수 출력

// DFS 구현
DFS 
{
    if(현재 노드 == 방문 노드) return;
    visited 배열에 현재 노드 방문 기록
    for(현재 노드에서 연결된 모든 노드 탐색) {
        if(현재 노드의 연결 노드 중 방문하지 않은 노드) {
            DFS 실행(방문하지 않은 노드) // 재귀 함수 형태
        }
    }
}
```

### 4. 코드 구현하기

### [예제 코드](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/Do%20it!%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20C%2B%2B%20%ED%8E%B8/Chapter%204.%20%ED%83%90%EC%83%89/%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89/11724.cpp)

<br>

## 문제 024. 신기한 소수 (골드 5, 2023)

[문제 링크](https://www.acmicpc.net/problem/2023)

<br>

### 1. 문제 분석하기
DFS는 재귀 함수의 형태를 띈다.
<br>
여기서는 재귀 함수로 문제를 풀 수 있다.

<br>

### 2. 손으로 풀어 보기
소수는 약수가 1과 자기 자신인 수를 말한다.
<br>
예를 들어 4는 약수고 1, 2, 4이므로 소수가 아니고, 7은 1, 7이므로 소수이다.
<br>
<br>
우선 자릿수가 한 개인 소수는 2, 3, 5, 7 이므로 이 수부터 탐색을 시작한다.
<br>
4, 6, 8, 9를 제외한 가지치기 방식을 적용한 것이다.
<br>
<br>
이어서 자릿수가 두 개인 현재 수 * 10 / a 를 계산하여 이 수가 소수인지 판단하고, 소수라면 재귀 함수로 자릿수를 하나 늘린다.
<br>
단, a가 짝수인 경우 항상 2를 약수로 가지므로 가자치기로 a가 짝수인 경우를 제외한다.
<br>
<br>
이런 방식으로 자릿수를 N까지 확장했을 때 그 값이 소수라면 해당 값을 출력한다.

<br>


![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/7d601105-7e04-4f29-8978-bbe79d72ccca)


<br>

위 그림을 보면 DFS 형태로 탐색한다.
<br>
그리고 첫 탐색 배열, 중간 탐색 배열을 가지치기하여 시간 복잡도를 줄였다.
<br>
<br>
또한 중간 탐색 과정에서 소수가 아닌 경우 멈추는 가지치기도 포함되므로 제한 시간 내에 문제를 풀 수 있다.
<br>
<br>
소수를 판별하는 방법은 보통 에라토스테네스의 체를 사용하지만 여기서는 단순한 소수 판별 함수를 사용해도 시간 안에 문제를 풀 수 있다.

<br>

### 3. 슈도코드 작성하기

```
N(자릿수)
DFS 실행 (2, 3, 5, 7을 시작 수로 시작)

// DFS 구현
DFS(숫자, 현재 자릿 수) {
    if(자릿수 == N) {
        if(소수이면) 수 출력
        탐색 종료
    }
    for(1 ~ 9 반복) {
        if(뒤에 붙는 수가 홀수이면서 소수인 경우)
            DFS(수 * 10 + 뒤에 붙는 수, 현재 자릿수 + 1) 실행
    }
}

// 소수 구하기 함수
for(i를 2 ~ 현재 수/2까지 반복) {
    if(i로 나눈 나머지가 0이면) return 소수가 아님
}

return 소수임
```

<br>

### 4. 코드 구현하기
