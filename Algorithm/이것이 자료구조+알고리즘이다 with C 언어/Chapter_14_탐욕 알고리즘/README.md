![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/3526ff7f-7b6e-4e8f-8266-7f34492958b9)# 탐욕 알고리즘 정리 내용

## 탐욕(Greedy) 알고리즘
탐욕 알고리즘은 최적화 문제의 답을 얻기 위해 사용된다.
<br>
탐욕 이라는 이름은 각 단계의 부분 문제를 풀 때 근시안 적으로 최적해를 구한다고 해서 붙여졌다.
<br>
그래서 탐욕 알고리즘을 생각할 때는 욕심이나 탐욕 자체보다 탐욕이 우리로 하여금 가까운 것만 바라보게 하는 효과에 초점을 맞추는 편이 이해하는 데 도움이 된다.
<br>
<br>
탐욕 알고리즘은 반드시 최적해를 구해준다는 보장은 하지 못한다.
<br>
다만 최적해가 나오기를 '바랄' 수 있을 뿐이다.
<br>
<br>
탐욕 알고리즘으로 풀 수 있는 문제는 다음과 같이 대상 문제가 최적 부분 구조를 갖고 있어야 한다.
<br>
탐욕 알고리즘은 다음과 같은 과정으로 동작한다.
1. <b>해 선택</b> : 현재 상태에서 부분 문제의 최적해를 구한 후 이를 부분해 집합(Solution Set)에 추가
2. <b>실행 가능성 검사</b> : 새로운 부분해 집합이 실행 가능한 것인지 확인 즉, 문제의 제약 조건을 위반하지 않는지 검사
3. <b>해 검사</b> : 새로운 부분해 집합이 문제의 해가 되는지 확인하며 아직 전체 문제의 해가 완성되지 않았다면 1단계의 해 선택부터 다시 시작

<br>

## 거스름돈 줄이기 문제
거스름돈 줄이기 문제는 탐욕 알고리즘에서 많이 사용되는 문제이다.
<br>
예를 들어 편의점에서 손님에게 거스름돈을 주는 것을 최소한으로 줄일 수 있는 부분을 생각하는 상황이라고 가정한다.
<br>
<br>
예를 들어 물건 가격이 1,200 원인데, 손님이 1,000원짜리 지폐 2개를 지불하면 거스름돈 800원을 내어 주어야 한다.
<br>
이때 거스름돈을 100원짜리 8개로 줄 수도 있지만, 동전의 개수를 최소한으로 하려면 500원짜리 1개와 100원짜리 3개를 내어주어야 한다.
<br>
<br>
이 문제는 탐욕 알고리즘을 잘 이해할 수 있는 좋은 사례이다.
<br>
이 문제를 1단계 해 선택, 2단계 실행 가능성 검사, 3단계 해 검사로 정의하면 다음과 같다.
1. <b>해 선택</b> : 현재 고를 수 있는 가장 큰 단위의 동전을 하나 골라 거스름돈에 추가
2. <b>실행 가능성 검사</b> : 거스름돈이 손님에게 내주어야 할 액수보다 초과하는지 확인하고 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고 1단계로 돌아가서 현재보다 한 단계 작은 단위의 동전 추가
3. <b>해 검사</b> : 거스름돈 문제의 해를 구하는 단계로 거스름돈 액수가 모자라면 1단계로 돌아가 추가할 동전 선택

<br>

## 거스름돈 계산 예제 프로그램

### [예제 코드](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%2B%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%8B%A4%20with%20C%20%EC%96%B8%EC%96%B4/Chapter_14_%ED%83%90%EC%9A%95%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Change.c)

### 실행 결과

```
동전의 가짓수를 입력하세요 : 4
[0] 번째 동전의 단위를 입력하세요 : 500
[1] 번째 동전의 단위를 입력하세요 : 100
[2] 번째 동전의 단위를 입력하세요 : 50
[3] 번째 동전의 단위를 입력하세요 : 10
물건 가격을 입력하세요 : 1200
손님이 지불한 돈은 얼마입니까? : 2000
     500원 : 1개
     100원 : 3개
      50원 : 0개
      10원 : 0개
```

<br>

## 탐욕 알고리즘의 중요한 속성
대부분의 국가에서 사용하는 지폐와 동전의 단위는 탐욕 알고리즘이 항상 최적의 거스름돈을 만들 수 있는 형식으로 되어 있다.
<br>
예를 들어 우리나라의 동전은 500원, 100원, 50원, 10원 이렇게 네 가지가 있다.
<br>
이 다섯 가지 중 어느 두 개를 골라 두 동전 사이의 최대 공약수를 계사냏도 항상 작은 값의 동전 단위가 나온다.
<br>
<br>
예를 들어 500과 100의 최대 공약수는 100이고, 100과 10의 최대 공약수도 10이다.
<br>
<br>
이와 같은 체계에서는 누구나 최소 개수의 동전으로 이루어진 거스름돈을 만들 수 있다.
<br>
<br>
만약 400원짜리 동전을 새로 발행되었다고 가정한다.
<br>
400원짜리 동전이 있는 경우 800원의 거스름돈을 만들기 위한 최적의 해는 400원짜리 동전 2개를 내주는 것이다.
<br>
하지만 작성한 알고리즘대로라면 500원짜리를 먼저 선택해서 1개를 거스름돈에 추가하고 그 다음에서 400원짜리 동전을 선택하면 실행 가능성 검사에서 부적격 판정을 받는다.
<br>
500 + 400 = 900이 되므로 손님에게 내주어야 할 돈 800원을 초과하기 때문이다.
<br>
<br>
결국 다음 단계에서 100원짜리를 선택하게 되고 모두 4개의 동전을 손님에게 내주는 결과를 얻게 된다.

```
동전의 가짓수를 입력하세요 : 5
[0] 번째 동전의 단위를 입력하세요 : 500
[1] 번째 동전의 단위를 입력하세요 : 400
[2] 번째 동전의 단위를 입력하세요 : 100
[3] 번째 동전의 단위를 입력하세요 : 50
[4] 번째 동전의 단위를 입력하세요 : 10
물건 가격을 입력하세요 : 1200
손님이 지불한 돈은 얼마입니까? : 2000
     500원 : 1개
     400원 : 0개
     100원 : 3개
      50원 : 0개
      10원 : 0개
```

이 실행 결과를 살펴보면 거스름돈을 만드는 **탐욕 알고리즘의 해가 항상 최적은 아니다** 라는 사실을 알 수 있다.
<br>
거스름돈 알고리즘 처럼 항상 **최적의 결과를 보장하지 못한다는 부분**은 탐욕 알고리즘의 중요한 속성이다.

<br>

## 크루스칼 알고리즘 다시 보기
다음과 같은 그래프가 있다고 가정할 때 그래프 내 모든 정점을 최소 비용으로 연결하는 트리를 최소 신장 트리라고 한다.
<br>
최소 신장 트리를 구축할 때 한 가지 중요한 제약이 따라는데, 그건 최소 신장 트리 내에 사이클이 형성되어서는 안 된다는 점이다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/93d363e0-1ea0-4814-a2c4-a0bedbc90e70)

<br>

크루스칼 알고리즘은 다음 2단계로 동작한다.
1. 그래프 내 모든 간선을 가중치의 오름차순으로 정렬하여 목록 생성
2. 1단계에서 만든 간선의 목록을 차례대로 순회하면서 간선을 최소 신장 트리에 추가<br>단, 이때 추가된 간선으로 인해 최소 신장 트리 내에 사이클이 형성되면 안됨

크루스칼 알고리즘에서 탐욕적인 방법으로 처리되는 부분은 2단계이다.
<br>
탐욕 알고리즘이 해 선택-실행 가능성 검사- 해 검사 의 반복으로 이루어지는 부분이 크루스칼 알고리즘에서 간선 목록을 돌면서 최소 신장 트리를 완성해 나간다.
<br>
<br>
해 선택은 가장 작은 가중치의 간선을 선택함으로써 이루어진다.
<br>
정렬은 이미 끝났으므로 차례대로 선택하기만 하면 된다.
<br>
<br>
크루스칼 알고리즘에서 중요한 것은 실행 가능성 검사이다.
<br>
해 선택 단계에서 고른 간선이 신장 트리 내에 사이클을 형성한다면 이 간선을 버리고 다음 가중치의 간선을 골라야 하기 때문이다.
<br>
크루스칼 알고리즘은 사이클 탐지를 위해 분리 집합을 이용한다.
<br>
<br>
크루스칼 알고리즘은 간선을 추가할 때마다 간선 양 끝에 있는 정점들을 같은 집합에 추가한다.
<br>
이 2개의 정점이 이미 같은 집합에 소속되어 있다면 이 간선이 사이클을 형성한다고 판단한다.
<br>
<br>
예를 들어 아래와 같이 이미 가중치의 오름차순으로 간선이 연결되어 있고, 이제 막 F-H(가중치 120)을 추가하려는 상황이다.
<br>
그런데 정점 F와 H는 이미 같은 집합에 소속되어 있기 때문에 F-H 간선을 연결하면 사이클이 형성된다고 예측할 수 있다.
<br>
<br>
따라서 F-H는 실행 가능성 검사에서 거부당한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/5a9c1698-03f0-4ed9-a3d6-56f52fca2137)


<br>

그래서 다시 해 선택 단계로 넘어간다.
<br>
이번에는 가중치 126인 간선 B-C를 선택한다.
<br>
<br>
다시 실행 가능성 검사를 해보면 B-C 끝에 연결된 정점 B와 C는 현재 서로 다른 집합의 원소이다.
<br>
이 간선은 사이클을 형성하지 않으므로 실행 가능성 검사를 통과한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/e0567a41-18f0-4582-9a3a-e6d8f1043abe)

<br>

마지막으로 크루스칼 알고리즘 해 검사 방법으로는 모든 정점이 하나의 집합에 들어 있으면 해가 완성되었다고 판단할 수 있다.

<br>

## 다익스트라 알고리즘 다시 보기
다익스트라 알고리즘은 그래프 내의 한 정점에서 다른 정점으로 향하는 가장 짧은 경로를 구하는 알고리즘이다.
<br>
예를 들어 다음과 같은 그래르페엇 최소 비용으로 정점 B에서 I로 갈 수 있는 방법을 찾는 것이다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/1ed322ac-cc04-49d6-a6af-44c70df07637)


<br>

다익스트라 알고리즘은 다음과 같이 동작한다.
1. 각 정점에는 시작점으로부터 자신에게 이르는 경로의 길이를 저장할 곳을 준비하고 각 정점에 대한 경로의 길이를 무한대로 초기화
2. 시작 정점의 경로 길이를 0으로 초기화하고 최단 경로에 추가
3. 최단 경로에 새로 추가된 인접 정점에 대해 경로 길이를 갱신하고 이들을 최단 경로에 추가<br>만약 추가하려는 인접 정점이 이미 최단 경로 안에 있다면 갱신되기 이전의 경로 길이가 새로운 경로의 길이보다 더 큰 경우에 한해 다른 선행 정점을 지나던 기존 경로가 현재 정점을 경유하도록 수정
4. 그래프 내의 모든 정점이 최단 경로에 소속될 때까지 3단계 과정 반복

위 단계에서 1단계와 2단계는 사실 알고리즘의 초기화 작업에 해당하며 3, 4단계가 본격적으로 최단 경로를 만드는 과정이다.
<br>
3단계는 해 선택과 실행 가능성 검사, 4단계는 해 검사를 맡고 있다.
<br>
<br>
이해를 돕기 위해 아래와 같은 그래프가 있다.
<br>
먼저 알고리즘의 1단계와 2단계를 수행한다.
<br>
<br>
모든 정점의 경로 길이를 무한대로 초기화하고 시작 정점의 경로 길이만 0으로 초기화한다.
<br>
그리고 시작 정점을 최단 경로 안에 추가한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/052c65de-a262-47f3-ad56-32a9711cce47)


<br>

현재 시점에서 가장 마지막에 추가한 정점은 시작 정점 B이다.
<br>
시작 정점인 B에 인접한 정점 A, C, F를 최단 경로에 추가하고 각 정점에 이르기 위해 소요되는 비용을 기록한다.
<br>
<br>
B-A는 35, B-C는 126, B-F는 150이다.
<br>
이미 최단 경로 안에 들어 있던 정점들이 없으므로 실행 가능성 검사를 통과한다.
<br>
아직 최단 경로를 완성하지 못했으므로 4단계의 해 검사는 통과하지 못한다.
<br>
<br>
따라서 3단계를 반복한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/42fe45ad-e3a6-4982-9f9a-54dd0010a2aa)


<br>

앞에서 A, C, F 모두 3개의 정점이 최단 경로에 새로 추가되었다.
<br>
이 정점들에 대해 다시 3단계의 과정을 차근차근 적용하면 된다.
<br>
<br>
먼저 A 정점을 처리한다.
<br>
A 정점의 인접 정점은 E 하나이므로 E를 최단 경로에 추가하고 E에 이르는 비용을 기록한다.
<br>
<br>
비용은 282이며, 실행 가능성 검사는 통과하고 해 검사는 통과하지 못한다.
<br>
계속해서 C정점을 처리한다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/5eccfa67-b543-4e25-a10f-ee29c73de203)


<br>

C의 인접 정점에는 D, F, G가 있는데 현재 D의 경로 길이는 무한대이므로 B-C-D 경로의 비용을 그대로 입력하고 G 역시 경로 길이가 무한대이므로 B-C-G 경로의 비용을 입력한다.
<br>
D와 G는 둘 다 실행 가능성 검사를 통과한다.
<br>
<br>
하지만 F는 실행 가능성 검사에서 떨어진다.
<br>
이미 F는 최단 경로 안에 포함되어 있는 데다가 포함된 경로 B-F 비용은 150으로, 새로 추가하려는 B-C-F의 비용 288보다 작기 때문이다.
<br>
<br>
실행 가능성 검사를 통과하지 못했으므로, 다음 단계를 진행한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/85d2722a-7b8e-4f71-9a97-30c6acf93363)


<br>


## 허프만 코딩(Huffman Coding)
음악 저장 파일 포맷인 mp3와 이미지 저장 파일 포맷인 JPEG의 공통점은 허프만 코딩을 이용하는 압축 데이터 포맷이라는 점이다.
<br>
<br>
허프만 코딩은 1950년경 데이비드 허프만(David A Huffman)이 MIT 박사과정일 때 만든 알고리즘이다.
<br>
허프만은 로버트 파노 교수의 정보 이론 수업을 듣고 있는데, 시험 과 리포트를 선택해야 할 때 리포트를 선택했고, 교수로부터 내려온 리포트의 주제는 '가장 효울적인 이진 코드 기법을 고안하라' 였다.
<br>
<br>
허프만은 리포트를 제출했고, 그 리포트는 스승인 로버트 파노 교수의 샤논-파도 코딩보다 더 우수한 것으로 드러났고, 전 세게에서 가장 유명한 압축 알고리즘 중 하나가 되었다.
<br>
<br>
하프만 코딩을 알기 전에 먼저 접두어 코드(Prefix Code)라는 것을 알아야 한다.

<br>

## 고정 길이 코드와 접두어 코드
고정 길이 코드(Fixed Length Code)란 말 그대로 모든 코드의 길이가 똑같은 값을 갖는 코드 체계를 말한다.
<br>
자주 사용하는 ASCII가 대표적인 예인데, 이 코드 집합의 모든 코드는 8bit 길이를 가진다.
<br>
고정 길이 코드의 최대 장정믄 다루기 쉽다는 데 있다.
<br>
<br>
ASCII로 문자열을 표현하고 싶으면 8bit 길이의 데이터를 연속해서 이어 붙이면 되고 반대로 문자열의 각 요소를 알고 싶으면 8bit 단위로 끊어 읽으면 된다.
<br>
<br>
예를 들어 비트로 표시된 ASCII 코드 문자열 01100001011000100110001101100100을 확인하면 아래와 같다.
<br>
이 문자열을 8bit씩 쪼개고, 각 조각을 코드 집합에 정의된 값으로 표시한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/b2360bfb-7d76-4b4a-b095-10dfa421a772)


<br>

이렇게 해서 'abcd'를 나타내는 코드임을 쉽게 알 수 있다.
<br>
<br>
고정 길이 코드가 이처럼 연산의 편의를 위한 것이라면 가변 길이 코드(Variable Length Code)는 저장 공간 절약을 위해 사용된다.
<br>
가변 길이 코드는 저장 공간을 절약한다는 장점도 있지만 데이터 처리가 상당히 번거롭다는 단점도 있다.
<br>
<br>
접두어 코드(Prifix Code)는 가변 길이 코드의 한 종류로 접두어 코드는 무접두어 코드(Prefix Free Code) 라고 불리기도 하는데, 이 분야에서는 그냥 접두어 코드라고 부르는 것이 대세이다.
<br>
<br>
접두어 코드는 코드 집합의 어느 코드도 다른 코드의 접두어가 되지 않는 코드를 말한다.(이것을 접두어 속성(Prifix Property)라고 함)
<br>
예를 들어 코드 집합 { "0", "1", "01", "010" }은 접두아 코드가 아니다.
<br>
"0"이 "01"과 "010"의 접두어가 되기 때문이다.
<br>
<br>
반면 {"00", "010", "100", "101" }은 어느 코드도 다른 코드어의 접두어가 되지 않기 때문에 접두어 코드라고 할 수 있다.
<br>
<br>
예를 들어 a, b, c, d를 나타내는 접두어 코드가 다음과 같이 정의되어 있다고 가정한다.

```
a = 00
b = 010
c = 100
d = 101
```

이 코드대로라면 'abcd'는 00010100101 로 표현할 수 있다.
<br>
ASCII 로는 32bit가 필요한데, 접두어 코드로는 11bit 만으로 표현할 수 있다.
<br>
<br>
허프만 코딩은 이런 아이디어에 근거를 두고 있다.

<br>

## 허프만 트리 구축
허프만 코딩 알고리즘을 이해하려면 딱 두 가지만 기억하면 된다.
- 기호와 빈도
- 이진 트리

기호의 빈도는 한 기호가 데이터 안에서 차지하는 비율을 말한다.
<br>
'Programming' 이라는 문자열을 예로 들어보면 길이는 11이고 기호 'g', 'm', 'r'의 빈도는 2이며 'P', 'o', 'i'의 빈도는 1이다.
<br>
<br>
기호의 빈도는 길이가 짧은 접두어 코드를 빈도가 가장 높은 기호에 부여하기 위해 사용한다.
<br>
빈도가 높은 기호에 작은 접두어 코드를 부여하면 그만큼 저장 공간을 아낄 수 있기 때문이다.
<br>
즉, 압축률이 높아진다는 뜻이다.
<br>
<br>
예를 들어 어떤 문자열이 'a' 기호 20개와 'b' 기호 5개로 이루어진다고 가정한다.
<br>
'a'에 코드 100을, 'b'에 코드 11을 부여한다면 변환된 데이터의 크기는 3(100의 비트 수) * 20 + 2(11의 비트수) * 5 = 70 비트가 된다.
<br>
<br>
원본 문자열이 200비트 였으니 원본 크기 대비 35%로 압축되었다.
<br>
하지만 반대로 a에 코드 11, b에 코드 100을 부여한다면 2(11의 비트 수) * 20 + 3(100의 비트 수) * 5 = 55로 앞의 방법에 비해 15비트를 더 절약할 수 있다.
<br>
<br>
이진 트리는 접두어 코드를 표현하기 위해 사용한다.
<br>
트리의 노드에서 왼쪽 자식 노드는 0, 오른쪽 자식 노드는 1을 가리킨다.
<br>
<br>
이 트리에서 모든 기호는 잎 노드에만 기록되어 있으며 뿌리 노드에서부터 잎 노드까지 이르는 경로가 기호의 접두어 코드가 된다.
<br>
이러한 방식으로 접두어 코드를 표현하는 이진 트리를 허프만 트리(Huffman Tree) 라고 한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/aebdfc83-b6f2-4929-8917-cc23812e6e64)


<br>

이 트리를 보면 잎 노드는 모두 4개이고 노드들에 저장된 기호는 a, b, c, d이다.
<br>
뿌리 노드로부터 a 노드까지 이르는 경로는 0 하나 뿐이다.
<br>
따라서 a의 접두어 코드는 0이 된다.
<br>
<br>
뿌리 노드로부터 b 노드까지 이르는 경로에는 오른쪽(1), 왼쪽(0), 왼쪽(0) 노드가 존재하므로 100이 된다.
<br>
같은 방법으로 c와 d를 읽어보면 c는 101, d는 11이 된다.
<br>
<br>
여기서 알 수 있는 사실이 탐욕 알고리즘과 허프만 트리의 상관관계이다.
<br>
이 트리의 뿌리 노드에서 잎 노드에 이르는 경로가 길어지면 길어질수록 접두어 코드 역시 길어진다는 사실이다.
<br>
여기서 기호의 빈도는 기호를 어느 잎 노드에 입력할 것인가를 결정하기 위해 사용한다.
<br>
<br>
빈도가 높은 기호일수록 경로를 짧게, 빈도가 낮은 기호일수록 경로를 길게 가져가야 압축률이 높아진다.
<br>
그래서 빈도수가 높은 기호부터 경로가 짧은 노드를 차지할 수 있도록 만들어야 한다.
<br>
<br>
예를 들어 'aaabaacdd' 라는 문자열이 있다.
<br>
a의 빈도는 5이고 b, c는 1, 그리고 d는 2이다.
<br>
<br>
먼저 이 기호들은 빈도와 함께 다음 그림과 같이 노드로 생성한다.
<br>
여기서 원 위의 숫자는 빈도를 나타낸다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/833a843f-f3e6-4649-a275-4012c64a5d82)


<br>

허프만 트리에서 기호는 잎 노드에만 저장되므로 이 노드들은 끝까지 잎 노드로 남아야 한다.
<br>
따라서 이 노드들 위에 부모 노드를 만들어 연결시키면서 트리를 완성해야 한다.
<br>
<br>
지금부터는 탐욕 알고리즘의 3단계를 적용해서 이 문제를 풀어나가면 된다.
1. 해 선택
2. 실행 가능성 검사
3. 해 검사

우선 해를 선택해야 한다.
<br>
선택 기준은 현 시점에서 빈도가 가장 작은 노드 2개이다.
<br>
<br>
b, c가 모두 빈도 1로 가장 작은 노드들이므로 이 노드를 선택한 후 노드 위에 부모 노드를 새로 만들어 각각 왼쪽과 오른쪽에 연결시킨다.
<br>
<br>
이때 부모 노드의 빈도는 자식 노드 빈도의 합이 된다.
<br>
따라서 b, c의 부모 노드의 빈도는 2가 된다.
<br>
<br>
마지막으로 새로 만든 부모 노드를 노드 집합에 추가한다.
<br>
<br>
이제 실행 가능성 검사를 해야 한다.
<br>
기호를 가진 노드는 잎 노드여야 하는데 아직까지는 이 규칙을 위반하지 않고 있다.
<br>
따라서 실행 가능성 검사를 통과한다.
<br>
<br>
다음으로 해 검사를 해야 하는데, 허프만 트리를 완성하지 못했으므로 해 검사는 통과하지 못한다.
<br>
그래서 다시 해 선택 단계로 돌아가야 한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/96d4c93b-75b5-48dd-9e1a-ee275d0a7b27)


<br>

현재 상태에서는 이전 단계에서 새로 만든 노드(b, c의 부모 노드)와 d 노드의 빈도가 가장 작으므로 이 두 노드를 선택한다.
<br>
부모 노드를 새로 만들어 여기에 b, c의 부모 노드와 d 노드를 자식 노드로 연결시킨다.
<br>
<br>
기호를 가진 노드들은 잎 노드이므로 이번에도 실행 가능성 검사를 통과한다.
<br>
트리에 들어가지 못한 노드가 남아 있기 때문에 다시 해 선택 단계로 돌아간다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/26f15fbc-3a11-48f4-b977-14331268c0d4)


<br>

다시 해 선택 단계로, 빈도가 가장 작은 2개의 노드를 골라야 하는데 남은 노드는 2개이다.
<br>
새 노드를 만들고 여기에 노드 a와 b, c, d의 뿌리 노드를 자식 노드로 연결시킨다.
<br>
이제 이 새로운 노드를 노드 집합에 추가한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/ac3a8960-648c-4188-89fd-2129d155c12b)


<br>

이제 노드 집합에는 단 하나의 노드만 남아 있다.
<br>
이것은 곧 접두어 트리가 완성되었음을 의미한다.
<br>
<br>
이제 이 집합에서 남아 있는 노드를 꺼내면 이 노드가 곧 허프만 트리가 된다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/b355333e-f927-4ee4-a356-26e0cc56df52)


<br>

여기까지가 탐욕 알고리즘의 예제로 완성된 허프만 코딩 알고리즘이다.

## 데이터 압축
허프만 트리는 압축을 위해 만들었으므로, 이를 이용하여 'aaabaacdd'를 압축하려고 한다.
<br>
문자열의 각 요소를 차례대로 읽으면서 허프만 트리가 나타내는 해당 문자의 접두어 코드로 변환하면 압축이 된다.
<br>
<br>
압축 결과는 다음과 같다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/c905f03d-dbe2-4191-8a3d-72b83e7b12eb)

<br>

압축 결과는 000100001011111 이고 원본 데이터(ASCII)의 크기가 72비트 였는데 15비트로 압축되었다.

<br>


## 데이터 압축 해제
허프만 코딩은 압축뿐 아니라 압축을 풀어내는 방법도 제공한다.
1. 허프만 트리와 압축 해제된 데이터가 담길 버퍼를 준비
2. 압축 데이터에 아직 읽지 않은 부분이 남아 있다면 데이터를 한 비트 읽음
3. 읽어낸 비트가 0이면 현재 노드의 왼쪽 자식 노드, 1이면 오른쪽 자식 노드로 이동하며 현재 노드가 잎 노드면 버퍼에 저장된 기호를 추가하고 다시 뿌리 노드로 이동

쉽게 말해 비트를 읽을 때마다 잎 노드를 만나기 전까지 허프만 트리의 왼쪽과 오른쪽 노드를 순회하라는 의미이다.
<br>
이제 예를 들기 위해 000100001011111을 복원한다고 가정한다.
