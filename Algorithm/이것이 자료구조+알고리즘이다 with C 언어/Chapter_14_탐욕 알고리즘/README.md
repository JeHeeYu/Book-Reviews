# 탐욕 알고리즘 정리 내용

## 탐욕(Greedy) 알고리즘
탐욕 알고리즘은 최적화 문제의 답을 얻기 위해 사용된다.
<br>
탐욕 이라는 이름은 각 단계의 부분 문제를 풀 때 근시안 적으로 최적해를 구한다고 해서 붙여졌다.
<br>
그래서 탐욕 알고리즘을 생각할 때는 욕심이나 탐욕 자체보다 탐욕이 우리로 하여금 가까운 것만 바라보게 하는 효과에 초점을 맞추는 편이 이해하는 데 도움이 된다.
<br>
<br>
탐욕 알고리즘은 반드시 최적해를 구해준다는 보장은 하지 못한다.
<br>
다만 최적해가 나오기를 '바랄' 수 있을 뿐이다.
<br>
<br>
탐욕 알고리즘으로 풀 수 있는 문제는 다음과 같이 대상 문제가 최적 부분 구조를 갖고 있어야 한다.
<br>
탐욕 알고리즘은 다음과 같은 과정으로 동작한다.
1. <b>해 선택</b> : 현재 상태에서 부분 문제의 최적해를 구한 후 이를 부분해 집합(Solution Set)에 추가
2. <b>실행 가능성 검사</b> : 새로운 부분해 집합이 실행 가능한 것인지 확인 즉, 문제의 제약 조건을 위반하지 않는지 검사
3. <b>해 검사</b> : 새로운 부분해 집합이 문제의 해가 되는지 확인하며 아직 전체 문제의 해가 완성되지 않았다면 1단계의 해 선택부터 다시 시작

<br>

## 거스름돈 줄이기 문제
거스름돈 줄이기 문제는 탐욕 알고리즘에서 많이 사용되는 문제이다.
<br>
예를 들어 편의점에서 손님에게 거스름돈을 주는 것을 최소한으로 줄일 수 있는 부분을 생각하는 상황이라고 가정한다.
<br>
<br>
예를 들어 물건 가격이 1,200 원인데, 손님이 1,000원짜리 지폐 2개를 지불하면 거스름돈 800원을 내어 주어야 한다.
<br>
이때 거스름돈을 100원짜리 8개로 줄 수도 있지만, 동전의 개수를 최소한으로 하려면 500원짜리 1개와 100원짜리 3개를 내어주어야 한다.
<br>
<br>
이 문제는 탐욕 알고리즘을 잘 이해할 수 있는 좋은 사례이다.
<br>
이 문제를 1단계 해 선택, 2단계 실행 가능성 검사, 3단계 해 검사로 정의하면 다음과 같다.
1. <b>해 선택</b> : 현재 고를 수 있는 가장 큰 단위의 동전을 하나 골라 거스름돈에 추가
2. <b>실행 가능성 검사</b> : 거스름돈이 손님에게 내주어야 할 액수보다 초과하는지 확인하고 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고 1단계로 돌아가서 현재보다 한 단계 작은 단위의 동전 추가
3. <b>해 검사</b> : 거스름돈 문제의 해를 구하는 단계로 거스름돈 액수가 모자라면 1단계로 돌아가 추가할 동전 선택

<br>

## 거스름돈 계산 예제 프로그램

### [예제 코드](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%2B%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%8B%A4%20with%20C%20%EC%96%B8%EC%96%B4/Chapter_14_%ED%83%90%EC%9A%95%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Change.c)

### 실행 결과

```
동전의 가짓수를 입력하세요 : 4
[0] 번째 동전의 단위를 입력하세요 : 500
[1] 번째 동전의 단위를 입력하세요 : 100
[2] 번째 동전의 단위를 입력하세요 : 50
[3] 번째 동전의 단위를 입력하세요 : 10
물건 가격을 입력하세요 : 1200
손님이 지불한 돈은 얼마입니까? : 2000
     500원 : 1개
     100원 : 3개
      50원 : 0개
      10원 : 0개
```

<br>

## 탐욕 알고리즘의 중요한 속성
대부분의 국가에서 사용하는 지폐와 동전의 단위는 탐욕 알고리즘이 항상 최적의 거스름돈을 만들 수 있는 형식으로 되어 있다.
<br>
예를 들어 우리나라의 동전은 500원, 100원, 50원, 10원 이렇게 네 가지가 있다.
<br>
이 다섯 가지 중 어느 두 개를 골라 두 동전 사이의 최대 공약수를 계사냏도 항상 작은 값의 동전 단위가 나온다.
<br>
<br>
예를 들어 500과 100의 최대 공약수는 100이고, 100과 10의 최대 공약수도 10이다.
<br>
<br>
이와 같은 체계에서는 누구나 최소 개수의 동전으로 이루어진 거스름돈을 만들 수 있다.
<br>
<br>
만약 400원짜리 동전을 새로 발행되었다고 가정한다.
<br>
400원짜리 동전이 있는 경우 800원의 거스름돈을 만들기 위한 최적의 해는 400원짜리 동전 2개를 내주는 것이다.
<br>
하지만 작성한 알고리즘대로라면 500원짜리를 먼저 선택해서 1개를 거스름돈에 추가하고 그 다음에서 400원짜리 동전을 선택하면 실행 가능성 검사에서 부적격 판정을 받는다.
<br>
500 + 400 = 900이 되므로 손님에게 내주어야 할 돈 800원을 초과하기 때문이다.
<br>
<br>
결국 다음 단계에서 100원짜리를 선택하게 되고 모두 4개의 동전을 손님에게 내주는 결과를 얻게 된다.

```
동전의 가짓수를 입력하세요 : 5
[0] 번째 동전의 단위를 입력하세요 : 500
[1] 번째 동전의 단위를 입력하세요 : 400
[2] 번째 동전의 단위를 입력하세요 : 100
[3] 번째 동전의 단위를 입력하세요 : 50
[4] 번째 동전의 단위를 입력하세요 : 10
물건 가격을 입력하세요 : 1200
손님이 지불한 돈은 얼마입니까? : 2000
     500원 : 1개
     400원 : 0개
     100원 : 3개
      50원 : 0개
      10원 : 0개
```

이 실행 결과를 살펴보면 거스름돈을 만드는 **탐욕 알고리즘의 해가 항상 최적은 아니다** 라는 사실을 알 수 있다.
<br>
거스름돈 알고리즘 처럼 항상 **최적의 결과를 보장하지 못한다는 부분**은 탐욕 알고리즘의 중요한 속성이다.

<br>

## 크루스칼 알고리즘 다시 보기
다음과 같은 그래프가 있다고 가정할 때 그래프 내 모든 정점을 최소 비용으로 연결하는 트리를 최소 신장 트리라고 한다.
<br>
최소 신장 트리를 구축할 때 한 가지 중요한 제약이 따라는데, 그건 최소 신장 트리 내에 사이클이 형성되어서는 안 된다는 점이다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/93d363e0-1ea0-4814-a2c4-a0bedbc90e70)

<br>

크루스칼 알고리즘은 다음 2단계로 동작한다.
1. 그래프 내 모든 간선을 가중치의 오름차순으로 정렬하여 목록 생성
2. 1단계에서 만든 간선의 목록을 차례대로 순회하면서 간선을 최소 신장 트리에 추가<br>단, 이때 추가된 간선으로 인해 최소 신장 트리 내에 사이클이 형성되면 안됨

크루스칼 알고리즘에서 탐욕적인 방법으로 처리되는 부분은 2단계이다.
<br>
탐욕 알고리즘이 해 선택-실행 가능성 검사- 해 검사 의 반복으로 이루어지는 부분이 크루스칼 알고리즘에서 간선 목록을 돌면서 최소 신장 트리를 완성해 나간다.
<br>
<br>
해 선택은 가장 작은 가중치의 간선을 선택함으로써 이루어진다.
<br>
정렬은 이미 끝났으므로 차례대로 선택하기만 하면 된다.
<br>
<br>
크루스칼 알고리즘에서 중요한 것은 실행 가능성 검사이다.
<br>
해 선택 단계에서 고른 간선이 신장 트리 내에 사이클을 형성한다면 이 간선을 버리고 다음 가중치의 간선을 골라야 하기 때문이다.
<br>
크루스칼 알고리즘은 사이클 탐지를 위해 분리 집합을 이용한다.
<br>
<br>
크루스칼 알고리즘은 간선을 추가할 때마다 간선 양 끝에 있는 정점들을 같은 집합에 추가한다.
<br>
이 2개의 정점이 이미 같은 집합에 소속되어 있다면 이 간선이 사이클을 형성한다고 판단한다.
<br>
<br>
예를 들어 아래와 같이 이미 가중치의 오름차순으로 간선이 연결되어 있고, 이제 막 F-H(가중치 120)을 추가하려는 상황이다.
<br>
그런데 정점 F와 H는 이미 같은 집합에 소속되어 있기 때문에 F-H 간선을 연결하면 사이클이 형성된다고 예측할 수 있다.
<br>
<br>
따라서 F-H는 실행 가능성 검사에서 거부당한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/5a9c1698-03f0-4ed9-a3d6-56f52fca2137)


<br>

그래서 다시 해 선택 단계로 넘어간다.
<br>
이번에는 가중치 126인 간선 B-C를 선택한다.
<br>
<br>
다시 실행 가능성 검사를 해보면 B-C 끝에 연결된 정점 B와 C는 현재 서로 다른 집합의 원소이다.
<br>
이 간선은 사이클을 형성하지 않으므로 실행 가능성 검사를 통과한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/e0567a41-18f0-4582-9a3a-e6d8f1043abe)

<br>

마지막으로 크루스칼 알고리즘 해 검사 방법으로는 모든 정점이 하나의 집합에 들어 있으면 해가 완성되었다고 판단할 수 있다.

<br>

## 다익스트라 알고리즘 다시 보기
다익스트라 알고리즘은 그래프 내의 한 정점에서 다른 정점으로 향하는 가장 짧은 경로를 구하는 알고리즘이다.
<br>
예를 들어 다음과 같은 그래르페엇 최소 비용으로 정점 B에서 I로 갈 수 있는 방법을 찾는 것이다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/1ed322ac-cc04-49d6-a6af-44c70df07637)


<br>

다익스트라 알고리즘은 다음과 같이 동작한다.
1. 각 정점에는 시작점으로부터 자신에게 이르는 경로의 길이를 저장할 곳을 준비하고 각 정점에 대한 경로의 길이를 무한대로 초기화
2. 시작 정점의 경로 길이를 0으로 초기화하고 최단 경로에 추가
3. 최단 경로에 새로 추가된 인접 정점에 대해 경로 길이를 갱신하고 이들을 최단 경로에 추가<br>만약 추가하려는 인접 정점이 이미 최단 경로 안에 있다면 갱신되기 이전의 경로 길이가 새로운 경로의 길이보다 더 큰 경우에 한해 다른 선행 정점을 지나던 기존 경로가 현재 정점을 경유하도록 수정
4. 그래프 내의 모든 정점이 최단 경로에 소속될 때까지 3단계 과정 반복

위 단계에서 1단계와 2단계는 사실 알고리즘의 초기화 작업에 해당하며 3, 4단계가 본격적으로 최단 경로를 만드는 과정이다.
<br>
3단계는 해 선택과 실행 가능성 검사, 4단계는 해 검사를 맡고 있다.
<br>
<br>
이해를 돕기 위해 아래와 같은 그래프가 있다.
<br>
먼저 알고리즘의 1단계와 2단계를 수행한다.
<br>
<br>
모든 정점의 경로 길이를 무한대로 초기화하고 시작 정점의 경로 길이만 0으로 초기화한다.
<br>
그리고 시작 정점을 최단 경로 안에 추가한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/052c65de-a262-47f3-ad56-32a9711cce47)


<br>

현재 시점에서 가장 마지막에 추가한 정점은 시작 정점 B이다.
<br>
시작 정점인 B에 인접한 정점 A, C, F를 최단 경로에 추가하고 각 정점에 이르기 위해 소요되는 비용을 기록한다.
<br>
<br>
B-A는 35, B-C는 126, B-F는 150이다.
<br>
이미 최단 경로 안에 들어 있던 정점들이 없으므로 실행 가능성 검사를 통과한다.
<br>
아직 최단 경로를 완성하지 못했으므로 4단계의 해 검사는 통과하지 못한다.
<br>
<br>
따라서 3단계를 반복한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/42fe45ad-e3a6-4982-9f9a-54dd0010a2aa)


<br>

앞에서 A, C, F 모두 3개의 정점이 최단 경로에 새로 추가되었다.
<br>
이 정점들에 대해 다시 3단계의 과정을 차근차근 적용하면 된다.
<br>
<br>
먼저 A 정점을 처리한다.
<br>
A 정점의 인접 정점은 E 하나이므로 E를 최단 경로에 추가하고 E에 이르는 비용을 기록한다.
<br>
<br>
비용은 282이며, 실행 가능성 검사는 통과하고 해 검사는 통과하지 못한다.
<br>
계속해서 C정점을 처리한다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/5eccfa67-b543-4e25-a10f-ee29c73de203)


<br>

C의 인접 정점에는 D, F, G가 있는데 현재 D의 경로 길이는 무한대이므로 B-C-D 경로의 비용을 그대로 입력하고 G 역시 경로 길이가 무한대이므로 B-C-G 경로의 비용을 입력한다.
<br>
D와 G는 둘 다 실행 가능성 검사를 통과한다.
<br>
<br>
하지만 F는 실행 가능성 검사에서 떨어진다.
<br>
이미 F는 최단 경로 안에 포함되어 있는 데다가 포함된 경로 B-F 비용은 150으로, 새로 추가하려는 B-C-F의 비용 288보다 작기 때문이다.
<br>
<br>
실행 가능성 검사를 통과하지 못했으므로, 다음 단계를 진행한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/85d2722a-7b8e-4f71-9a97-30c6acf93363)


<br>
