# 백트래킹 정리 내용

## 백트래킹(Backtracking) 개요
백트래킹 알고리즘은 1950년대에 처음 등장한 알고리즘으로 문제의 해가 될 수 있는 후보를 찾고, 해가 될 수 있는 후보를 찾고, 해가 될 수 있는 조건을 충족하지 못하는 후보를 제거해나가면서 최종 해를 찾는 기법이다.
<br>

## 백트래킹 개념
백트래킹은 여러 후보해 중 특정 조건을 충족시키는 모든 해를 찾는 알고리즘이다.
<br>
백트래킹이 다루는 문제들은 해가 하나 이상 존재한다.
<br>
해가 둘, 셋, 수백, 수천 개일 수도 있다.
<br>
<br>
예를 들어 탈출로가 2개인 미로 문제는 해가 2개라고 할 수 있는데, 이 두 해를 일컬어 '모든 해'라고 한다.
<br>
미로의 한 지점에서 탈출구로 향하는 경로 속에는 여러 길목이 있는데 이들 각 길목에서 왼쪽으로 갈지 오른쪽으로 갈지 또는 계속 가던 방향으로 갈지의 물음(부분 문제)에 답(부분해)을 구하는 과정을 반복하면서 완성한 것이 탈출로(해)이다.
<br>
<br>
여기에서 부분 문제의 답은 어느 것이든 될 수 있다.
<br>
그 이유는 선택한 방향으로 끝까지 가봐야 '해를 이루는 부분해'가 될지 안될지 알 수 있으니까 이다.
<br>
<br>
게다가 선택한 밯양으로 가다 보면 새로운 길목을 만나게 될 것이고, 그곳에서 다시 여러 가능성을 두고 선택해야 하는 상황이 온다.
<br>
이렇게 **해가 될 수 있는 가능성을 가진 부분해의 조합을 두고 후보해**라고 한다.
<br>
<br>
백트래킹이 다루는 문제들은 대부분 후보해의 수가 굉장히 많다는 특징이 있다.
<br>
이 중에서 해가 될 **조건을 만족시키는 '진짜 해'를 효율적으로 찾는 것이 백트래킹의 목적**이다.
<br>
<br>
Backtrack은 '오던 길을 따라 되돌아 나오다' 라는 뜻을 갖고 있다.
<br>
이 단어의 동명사인 Backtracking은 번역하면 '되돌아 나오기'라는 뜻이 된다.
<br>
<br>
예를 들어 아래 그림과 같은 미로에서 탈출로를 찾아야 한다면 미로가 단순하므로 한눈에 탈출로를 찾아낼 수 있다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/590f461d-316c-4e28-a8df-5c72851bcc35)

<br>

그러냐 여기서는 방금 찾아낸 탈출로를 머릿속에서 지우고 자신이 미로 속에 있다고 가정한다.
<br>
지금 S 지점에 위치해 있으며 탈출구가 있는 G 지점까지 이동해야 한다.
<br>
<br>
길목에 붙인 번호는 길목에서 나뉘는 길들을 구분하기 위해 임의로 매긴 번호이다.
<br>
길을 가다가 이 길목을 만나면 어느 쪽으로 갈 것인지 선택해야 한다.
<br>
이 선택에 대한 경우의 수를 트리로 나타내면 다음과 같다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/11702be4-1ddb-4a9b-be99-f406a6569de3)

<br>
출발점 S를 지나 만나는 새로운 길은 1번과 2번 두 가지이다.
<br>
1번 길 끝에는 더 이상 새로운 길이 나오지 않고, 2번 길에는 3번과 4번으로 갈 수 있는 길목이 나온다.
<br>
4번 길로 가면 막다른 곳이 나오고 3번 길을 따라가면 5번과 6번을 선택할 수 있는 길목이 나온다.
<br>
5번 길에서는 새로운 길이 나오지 않고 6번 길을 따라가면 목표 지점인 탈출구 G를 만날 수 있다.
<br>
<br>
이러한 규칙으로 미로를 탐색하면 탐색 규칙은 다음과 같다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/4b36b0ba-b354-46e2-b694-82f4feb3928e)


<br>

갈림길이 나오면 왼쪽 방향을 먼저 시도한다고 했는데, 두 번째 그림에서 1번 길을 시도 했는데 더 이상 갈 곳이 없으므로 이 후보해는 해가 아니라는 사실을 알 수 있다.
<br>
그레서 세 번째 그링메서 1번 길을 포기하고 오던 길로 되돌아와서(Backrack) 2번 길을 시도한다.
<br>
<br>
같은 일이 다섯 번째, 여섯 번째 그림에서도 나타난다.
<br>
5번 길을 먼저 시도했늗네 더 이상 계속 진행할 수 없어서 뒤로 돌아와 6번 길을 시도한다.
<br>
<br>
이런 과정을 반복한 끝에 여섯 번째 그림과 같이 탈출구를 찾게 된다.
<br>
<br>
드디어 S-2-3-6-G가 이 미로의 탈출로라는 사실을 알아낼 수 있다.
<br>
<br>
이 과정은 깊이 우선 탐색 알고리즘(DFS)과 비슷한 면이 있다.
<br>
깊이 우선 탐색은 모든 노드를 방문하는 것이 목적이고, 백트래킹은 해를 찾는 것이 목적이므로 꼭 모든 노드를 방문할 필요가 없다는 차이점이 있다.
<br>
<br>
백트래킹은 **해를 찾는 비용을 줄이기 위해 방문할 노드의 수를 최소화하는 것이 중요**하다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/864c2159-2191-4502-b01c-892d0b271f88)

<br>

백트래킹이 다루는 문제들은 다양한 후보해를 갖고 있는데 이 후보해들은 부분해로 이루어져 있어 미로 문제와 같이 트리 형태로 표현할 수 있다.
<br>
이러한 후보해 속에서 해를 찾는 과정은 다음과 같다.
1. 해를 찾아가는 과정은 '뿌리'에서 부터 출발 (뿌리도 하나의 부분해)
2. 현재 위치한 부분해에서 선택 가능한 다음 부분해의 목록을 얻음
3. 2단계에서 얻은 부분해들을 하나씩 방문
4. 방문한 부분해가 '해가 될 수 있는 조건'을 만족시키면 그 자리에서 2단계와 3단계를 수행하고, 그렇지 않으면 그 이전 부분해로 돌아 나와 다른 부분해를 시도
5. 최종해를 얻을 때까지 또는 모든 경우의 수를 확인해도 해가 없음을 확인할 때까지 2 ~ 4 단계 반복

<br>

## 미로 탈출로 찾기

### 재귀 호출 기반 백트래킹
앞서 봤던 미로를 트리로 표현하고 이 트리 속의 노드를 옮겨 다니면서 탈출구로 향하는 길을 알아냈다.
<br>
하지만 이 트리는 어디까지나 논리적인 개념이지 물리적인 존재가 아니다.
<br>
<br>
이말은 곧, 복잡한 트리 자료구조 없이도 미로 탈출 알고리즘을 구현할 수 있다는 뜻이다.
<br>
여러 방법으로 구현할 수 있지만, 여기서는 구현이 간편한 재귀 호출을 이용한다.
<br>


































