## 1.4 std::vector

std::array는 C 스타일 배열의 향상된 버전이지만, 실제로 유용하게 사용할 수 있는 몇몇 기능을 제공하지 않는 단점이 있다.
<br>
단점은 다음과 같다.
- std::array의 크기는 컴파일 시간에 결정되는 상수여야 하므로 프로그램 실행 중 변경할 수 없음
- 크기가 고정되어 있어 원소를 추가하거나 삭제할 수 없음
- std::array의 메모리 할당 방법을 변경할 수 없으며 항상 스택 메모리 사용

이러한 문제들로 인해 std::vector를 사용한다.

<br>

## 1.4.1 std::vector - 가변 크기 배열
std::vector는 고정 크기 문제를 해결하며, 초기화 과정에 데이터의 크기를 제공하지 않아도 된다.

```
// 크기가 0인 벡터 선언
std::vector<int> vec;

// 지정한 초깃값으로 이루어진 크기가 5인 벡터 선언
std::vector<int> vec = { 1, 2, 3, 4, 5 };

// 크기가 10인 벡터 선언
std::vector<int> vec(10);

// 크기가 10이고 모든 원소가 5로 초기화된 벡터 선언
std::vector<int> vec(10, 5);
```

벡터에 새로운 원소를 추가하려면 push_back() 또는 insert() 함수를 사용한다.
<br>
push_back() 함수는 벡터의 맨 마지막에 새로운 원소를 추가한다.
<br>
insert() 함수는 삽입할 위치를 나타내는 반복자를 첫 번째 인자로 받음으로써 원하는 위치에 추가한다.
<br>
<br>
push_back() 함수는 맨 뒤에 원소를 삽입할 때 뒤쪽에 남아 있는 공간이 있다면 O(1)의 시간이 걸린다.
<br>
그러나 공간이 충분하지 않으면 모든 원소를 복사/이동해야 하며, 이때는 O(n)의 시간이 걸린다.
<br>
<br>
insert() 함수의 경우, 지정한 반복자 위치 다음의 모든 원소를 이동시키는 연산이 필요하다.
<br>
필요한 경우 메모리를 새로 할당하는 작업도 수행된다.
<br>
<br>
원소들을 이동하는 연산 때문에 insert() 함수는 O(n)의 시간이 걸린다.

```
// 비어 있는 벡터 생성
std::vector<int> vec;

// 맨 뒤에 1 추가: {1}
vec.push_back(1);

// 맨 뒤에 2 추가: {1, 2}
vec.push_back(2); 

// 맨 앞에 0 추가: {0, 1, 2}
vec.insert(vec.begin(), 0);

// 1 앞에 4 추가 {0, 4, 1, 2}
vec.insert(find(vec.begin(), vec.end(), 1), 4);
```

push_back() 또는 insert() 함수의 단점 중 하나는 이들 함수가 추가할 원소를 먼저 임시로 생성한 후, 벡터 버퍼 내부 위치로 복사 또는 이동을 수행한다는 점이다.
<br>
이러한 단점은 새로운 원소가 추가될 위치에서 해당 원소를 생성하는 방식으로 최적화 할 수 있으며, 이러한 기능이 emplace_back() 또는 emplace() 함수에 구현되어 있다.
<br>
<br>
그러므로 push_back() 또는 insert() 같은 일반적인 삽입 함수 대신 emplace_back() 또는 emplace() 함수를 사용하는 것이 성능 향상에 도움이 된다.
<br>
이 경우 새 원소 위치에서 곧바로 객체가 생성되기 때문에 이들 함수 인자에 생성된 객체를 전달하는 것이 아니라 생성자에 필요한 매개변수를 전달해야 한다.
<br>
<br>
그러면 emplace_back() 또는 emplace() 함수가 전달된 생성자 인자를 적절하게 사용하여 객체를 생성하고 삽입한다.
<br>
<br>
std::vector는 원소 제거를 위해 pop_back()과 erase() 함수를 제공한다.
<br>
pop_back() 함수는 맨 마지막 원소를 제거하며 그 결과 벡터 크기는 1만큼 줄어든다.
<br>
<br>
erase() 함수는 두 가지 형태로 오버로딩되어 있다.
<br>
한 가지 형태는 반복자 하나를 인자로 받아 해당 위치 원소를 제거한다.
<br>
다른 형태는 범위의 시작과 끝을 나타내는 반복자를 받아 시작부터 끝 바로 앞 원소까지 제거한다.
<br>
<br>
즉, 시작 위치 원소는 제거되지만 끝 위치 원소는 제거되지 않는다.
<br>
<br>
pop_back() 함수는 남아 있는 위치를 조정할 필요가 없으므로 시간 복잡도는 O(1)이다.
<br>
그러나 erase() 함수는 특정 위치 원소를 삭제한 후 뒤쪽의 원소들을 모두 앞으로 이동해야 하기 때문에 O(n)의 시간이 소요된다.

```
// 10개의 데이터를 가지고 잇는 벡터 선언
std::vector<int> vec = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

// 맨 마지막 원소 제거: { 0, 1, 2, 3, 4, 5, 6, 7, 8 }
vec.pop_back();

// 맨 처음 원소 제거 { 1, 2, 3, 4, 5, 6, 7, 8 }
vec.erase(vec.begin());

// 1번째 원소부터 4번째 앞 원소까지 제거 { 1, 5, 6, 7, 8 }
vec.erase(vec.begin() + 1, vec.begin() + 4);
```

<br>

### 1.4.2 std::vector 할당자
std::vector는 템플릿 매개변수에서 데이터 타입 다음에 할당자를 전달할 수 있다.
<br>
사용자 정의 할당자를 사용하려면 정해진 인터페이스를 따라야 한다.
<br>
<br>
벡터는 메모리 접근과 관련된 대부분의 동작에서 할당자 함수를 사용하므로 할당자는 다음의 함수 등을 제공해야 한다.
- allocate()
- deallocate()
- construct()
- destroy()

할당자는 메모리 할당과 해제, 그리고 여타 동작에서 데이터를 손상시키지 않도록 주의해야 한다.
