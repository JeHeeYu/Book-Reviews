## std::forward_list

배열, 벡터 같은 연속된 자료 구조에서는 데이터의 자료를 추가하거나 삭제하는 작업이 매우 비효율적이다.
<br>
그래서 연결 리스트와 같은 형태의 자료 구조그 당장한다.
<br>
<br>
기본적으로 연결 리스트를 구성하려면 포인터를 하나 가지고 있어야 하고, new와 delete 연산자를 이용하여 메모리를 할당하고 해제할 수 있어야 한다.
<br>
이러한 기능을 구현하는 것이 어렵지는 않지만 잘못하면 버그를 얏안할 수 있다.
<br>
<br>
C++에서는 기본적인 연결 리스트에 대한 래퍼 클래스인 std::forward_list 클래스를 제공한다.
<br>
std::forward_List는 기본적인 연결 리스트의 성능을 유지하면서 추가적인 기능을 제공한다.
<br>
<br>
성능 유지를 위해 전체 리스트의 크기를 반환하거나 또는 첫 번째 원소를 제외한 나머지 원소에 직접 접근하는 기능을 제공하지 않는다.
<br>
즉, 맨 처음 원소에 접근하는 front() 함수를 제공하지만, 반대 방향의 원소로 이동하는 back() 같은 함수는 제공하지 않는다.
<br>
원소의 삽입, 삭제, 순서 뒤집기, 분할을 위한 기능은 제공하나 이러한 기능은 기본적인 연결 리스트의 메모리 사용량이나 성능에 영향을 주지 않는다.


<br>


### 1.5.1 std::forward_list에서 원소 삽입과 삭제
std::forward_list에서 원소를 삽입할 때에는 push_front()와 insert_after() 함수를 사용한다.
<br>
push_front() 함수는 연결 리스트 맨 앞에 새로운 원소를 삽입한다.
<br>
std::forward_list는 마지막 원소에 직접 접근할 수 없으므로 back() 함수는 제공하지 않는다.
<br>
<br>
그래서 특정 위치에 원소를 삽입하기 위해 insert_after() 함수를 사용해야 한다.
<br>
<br>
이는 연결리스트에서 새로운 원소를 삽입한 후 허용되지 않으므로 특정 원소 뒤에 새로운 원소를 삽입한 후 해당 원소의 next 포인터를 수정해야 한다.
<br>
<br>
연결 리스트에서 원소 삽입은 노드의 포인터 조작으로 구현되므로 삽입 후 다른 원소를 이동할 필요가 없다.
<br>
그러므로 std::forward_list의 삽입 함수는 모두 배열 기반 구조에서의 삽입 함수에 비해 매우 빠르게 동작한다.
<br>
삽입 함수는 리스트의 원소 크기에 영향을 받지 않으며 시간 복잡도는 O(1)이다.

```
// 연결 리스트 생성
std::forward_list<int> fwd_lst = { 1, 2, 3 };

// 맨 앞에 0 추가: { 0, 1, 2, 3 }
fwd_list.push_front(0);

auto it = fwd_list.begin();

// 맨 처음 원소 뒤에 5 추가: { 0, 5, 1, 2, 3 }
fwd_list.insert_after(it, 5);

// 같은 위치에 6 추가 { 0, 6, 5, 1, 2, 3 }
fwd_list.insert_after(it, 6);
```

std::forward_list에서 원소를 삭제할 때에는 pop_front()와 erase_after() 함수를 사용한다.
<br>
pop_front() 함수는 리스트의 맨 처음 원소를 제거하는데, 이 작업은 원소 이동이 필요하지 않으므로 매우 빠르게 동작하여 시간 복잡도는 O(1)이다.
<br>
<br>
erase_after()는 두 가지 형태로 제공된다.
<br>
하나는 특정 원소를 가리키는 반복자를 인자로 받아서 다음 위치의 원소를 삭제한다.
<br>
일련의 원소를 제거할 때에도 erase_after() 함수를 사용할 수 있으며, 이 경우에는 삭제할 범위의 시작 원소 앞을 가리키는 반복자와 삭제할 범위 끝 원소를 가리키는 반복자를 인자로 받는다.

```
// 연결 리스트 생성
std::forward_list<int> fwd_list = { 1, 2, 3, 4, 5};

// 맨 앞 원소 삭제: { 2, 3, 4, 5 }
fwd_list.pop_front();

auto it = fwd_list.begin();

// 맨 앞의 다음 원소를 삭제: { 2, 4, 5 }
fwd_list.erase_after(it);

// 맨 앞 원소 다음부터 맨 마지막 원소까지 삭제: { 2 }
fwd_List.erase_after(it, fwd_list.end());
```

<br>

### 1.5.2 std::forward_list의 기타 멤버 함수
반복자로 원소 위치를 저장하여 삭제하는 erase() 함수 이외, 원소 값을 검사하여 삭제하는 remove()와 remove_if() 함수도 제공한다.
<br>
<br>
remove() 함수는 삭제할 원소 값 하나를 매개변수로 받는다.
<br>
이 함수는 저장된 데이터 타입에 정의된 등호 연산자를 사용하여 전달된 값과 일치하는 모든 원소를 찾아 삭제한다.
<br>
저장된 데이터 타입에서 등호 연산이 지원되지 않으면 remove() 함수를 사용할 수 없으며, 이 경우 컴파일러는 에러를 발생시킨다.

### 1.5.3 연습 문제 3: [연결 리스트에서 remove_if() 함수를 이용한 조건부 원소 삭제](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC%20%EC%9C%84%ED%95%9C%20%EC%9E%90%EB%A3%8C%20%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20with%20C%2B%2B/1%EC%9E%A5%20%EB%A6%AC%EC%8A%A4%ED%8A%B8%2C%20%EC%8A%A4%ED%83%9D%2C%20%ED%81%90/1.5%20std%3A%3Aforward_list/citizen.cpp)

<br>

### 실행 결과

```
전체 시민들: [Kim, 22] [Lee, 25] [Park, 18] [Jin, 16] 
투표권이 있는 시민들: [Kim, 22] [Lee, 25] 
내년에 투표권이 생기는 시민들: [Park, 18]
```

