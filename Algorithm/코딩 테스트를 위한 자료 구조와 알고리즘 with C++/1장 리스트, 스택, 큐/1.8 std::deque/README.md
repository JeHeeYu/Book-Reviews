## std::deque

덱(deque)은 양방향 큐(Double-Ended Queue)의 약자이다.

<br>

### 1.8.1 덱의 구조

C++ 표준은 덱의 동작에 있어 다음 조건을 만족해야 한다고 규정한다.
- push_front(), pop_front(), push_back(), pop_back() 동작이 O(1) 시간 복잡도로 동작해야 함
- 모든 원소에 대해 임의 접근 동작이 O(1) 시간 복잡도로 동작해야 함
- 덱 중간에서 원소 삽입 또는 삭제는 O(n) 시간 복잡도로 동작해야 하며, 실제로는 최대 n / 2 단계로 동작하며 여기서 n은 덱의 크기임

이 요구 사항을 보면 덱은 양방향으로 매우 빠르게 확장할 수 있어야 하며, 모든 임의 원소에 임의 접근을 제공해야 한다.
<br>
자료 구조가 벡터와 비슷하지만 앞쪽과 뒤쪽으로 모두 확장할 수 있다는 점이 다르다.
<br>
<br>
원소 삽입과 삭제 시 n / 2 단계를 허용 한다는 점에서 이 연산이 모든 원소를 이동시키는 동작을 수행한다는 점을 예상할 수 있다.
<br>
<br>
덱은 어느 방향으로든 빠르게 확장할 수 있으므로 원소 삽입 시 나머지 원소를 항상 오른쪽으로 이동해야 하는 것은 아니다.
<br>
원소 삽입 위치에서 가장 가까운 끝 쪽으로 나머지 원소를 이동해도 된다.
<br>
<br>
특정 위치에서 가장 가까운 끝은 컨테이너 내부의 삽입 위치에서 n / 2 이상 떨어져 있을 수 없기 때문에 최대 n / 2 단계의 시간 복잡도를 가진다.
<br>
<br>
덱은 단일 메모리 청크를 사용하지 않으며 대신 크기가 같은 여러 개의 메모리 청크를 사용하여 데이터를 저장한다.
<br>
이 경우, 청크의 인덱스 및 크기를 이용하여 특정 위치의 원소가 어느 청크에 저장되어 있는지를 알 수 있다.
<br>
모든 메모리 청크 주소를 연속적인 메모리 구조에 저장해놓고 사용하면 O(1)의 시간 복잡도로 원소의 임의 접근이 가능해진다.
<br>
따라서 덱의 구조는 배열 또는 벡터와 유사하다고 가정한다.
<br>
<br>
덱의 맨 앞에 새로운 원소를 추가할 경우, 만약 첫 번째 메모리 청크에 여유 공간이 없다면 새로운 청크를 할당하고, 이 메모리 청크 주소를 맨 첫 번째 메모리 청크 주소로 설정한다.
<br>
이 작업을 수행하려면 청크 주소를 저장하는 메모리 공간은 새로 할당해야 하지만, 실제 원소 데이터는 전혀 이동시키지 않아도 된다.
<br>
<br>
메모리 재할당을 최소화하려면 첫 번째 청크부터 원소를 추가하지 않고 중간 위치의 청크부터 원소를 저장할 수 있다.
<br>
이러한 방식을 사용하면 일정 횟수의 push_front() 함수에 대해 매모리 재할당을 피할 수 있다.
<br>
<br>
덱은 벡터와 리스트에서 제공되는 함수를 조합한 것 이상의 기능을 제공한다.
<br>
덱은 push_front(), push_back(), insert(), emplace_front(), emplace_back() 등 여러 함수를 제공한다.
<br>
또한 벡터에서 저장 용량 최적화를 위해 사용하는 shrink_to_fit() 같은 함수도 지원한다.

```
// std::deque를 이용한 예제

// 덱 선언
std::deque<int> deq = { 1, 2, 3, 4, 5 };

// 맨 앞에 0 추가 : { 0, 1, 2, 3, 4, 5 }
deq.push_front(0);

// 맨 뒤에 6 추가 : { 0, 1, 2, 3, 4, 5, 6 }
deq.push_back(6);

// 맨 앞에서 2칸 뒤에 10 추기 : { 0, 1, 10, 2, 3, 4, 5, 6 }
deq.insert(deq.begin() + 2, 10);

// 맨 뒤 원소 삭제 : { 0, 1, 10, 2, 3, 4, 5 }
deq.pop_back();

// 맨 앞 원소 삭제 { 1, 10, 2, 3, 4, 5 }
deq.pop_front();

// { 1, 2, 3, 4, 5 }
deq.erase(deq.begin() + 1);

// { 1, 2, 3 }
deq.erase(deq.begin() + 3, deq.end());
```
