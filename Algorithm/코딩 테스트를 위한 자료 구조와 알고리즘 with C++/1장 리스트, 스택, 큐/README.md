# 1장 리스트 스택 큐 정리 내용

## 1.2. 연속된 자료 구조와 연결된 자료 구조
응용 프로그램에서 데이터를 처리하기 앞서 데이터를 어떻게 저장할 것인가를 결정해야 한다.
<br>
지연 시간, 사용 메모리, 또는 기타 매개변수 측면에서 최선의 성능을 제공하도록 구현 방법을 선택해야 한다.
<br>
<br>
어떠한 자료 구조를 선택할 것인가를 결정함에 있어 적합한 지표로 알고리즘 복잡도 또는 시간 복잡도(Time Complexity)가 있다.
<br>
<br>
시간 복잡도는 특정 작업을 수행하는 데 걸리는 시간을 데이터 크기에 대한 수식으로 표현하는 방식이다.
<br>
따라서 시간 복잡도는 데이터 크기가 변경되면 연산 시간이 어떻게 변하는지를 보여준다.
<br>
서로 다른 연산의 시간 복잡도는 그 내부에서 데이터를 어떻게 저장하여 사용하는가에 따라 달라진다.

### 1.2.1 연속된 자료 구조
연속된 자료 구조는 모든 원소를 단일 메모리 청크(Chunk)에 저장한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/7f2d1906-1901-4be4-935d-32872843741e)

<br>

바깥쪽 큰 사각형은 모든 원소가 저장되어 있는 단일 메모리 청크를 나타내고, 안쪽 작은 사각형들은 각각의 원소가 저장된 메모리 공간을 의미한다.
<br>
이 그림에서 각각의 원소는 모두 같은 타입을 사용한다.
<br>
그러므로 모든 원소는 같은 크기의 메모리를 사용하고, 이는 sizeof(type)으로 표시된다.
<br>
<br>
첫 번째 메모리 주소를 시작 주소(BA, Base Address)라고 한다.
<br>
<br>
모든 원소가 같은 타입이기 때문에 두 번째 원소의 위치는 BA + sizeof(type)이고, 그 다음 원소의 위치는 BA + 2 * sizeof(type)이 된다.
<br>
<br>
나머지 원소도 이와 같은 방식으로 계산할 수 있다.
<br>
즉, i 번째 원소에 접근하려면 BA + i * sizeof(type) 수식을 사용한다.
<br>
<br>
이러한 자료 구조에서는 배열의 전체 크기에 상관 없이 앞서 설명한 수식을 이용하여 모든 원소에 곧바로 접근할 수 있다.
<br>
따라서 데이터의 접근 시간은 항상 일정한데, 이러한 경우를 빅오(Big-O) 표기법으로 나타내면 O(1)로 표시한다.
<br>
<br>
배열의 유형은 크게 정적 배열(Static Array)과 동적 배열(Dynamic Array) 두 가지로 나눌 수 있다.
<br>
정적 배열은 선언된 블록이 끝나면 소멸되고, 동적 배열은 프로그래머가 자유롭게 결정한다.
<br>
<br>
정적 배열은 스택 메모리 여역에 할당되므로 함수가 종료되면 자동으로 해제된다.
<br>
반면 동적 배열은 힙 영역에 할당되며 사용자가 직접 해제하기 전까지 유지된다.
<br>
<br>
배열 같은 연속된 자료 구조에서 각 원소는 서로 인접해 있기 때문에 하나의 원소에 접근할 때 그 옆에 있는 원소 몇 개도 함께 캐시로 가져온다.
<br>
그러므로 다시 주변 원소에 접근하 ㄹ때 해당 원소를 캐시에서 가져오게 되며, 이 작업은 매우 빠르게 동작한다.
<br>
이러한 속성을 캐시 지역성(Cache Locality)이라고 한다.
<br>
<br>
어떤 연산의 점근적 시간 복잡도 계산에는 영향을 주지 않지만 실제 동작에는 배열처럼 연속된 원소에 매우 빠르게 접근할 수 있다는 점은 큰 장점이 된다.
<br>
배열에서 모든 원소에 순차적으로 접근하는 경우, 첫 번째 원소를 가져온 후 다음 원소는 캐시에서 바로 참조할 수 있으므로 배열은 캐시 지역성이 좋다고 말할 수 있다.

<br>

### 1.2.2. 연결된 자료 구조(Linked Data Structures)
연결된 자료 구조는 노드(Node)라고 하는 여러 개의 메모리 청크에 데이터를 저장하며, 이 경우 서로 다른 메모리 위치에 데이터가 저장된다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/275ef78d-26c4-4d3e-bb94-a24811eef7fc)


<br>

위와 같은 형태로 구성된 자료 구조를 연결 리스트(Linked List)라고 한다.
<br>
연결 리스트의 기본 구조에서 각각의 노드는 저장할 데이터와 다음 노드를 가리키는 포인터를 가지고 있다.
<br>
<br>
맨 마지막 노드에서는 다음 노드의 포인터 대신 자료 구조의 끝을 나타내는 NULL을 가진다.
<br>
<br>
연결 리스트에서 특정 원소에 접근하려면 리스트의 시작 부분, 즉 헤드 부분부터 시작하여 원하는 원소에 도달할 때까지 next 포인터를 따라 이동해야 한다.
<br>
그러므로 i 번째 원소에 접근하려면 연결 리스트 내부를 i번 이동하는 작업이 필요하다.
<br>
<br>
이때 원소 접근 시간은 노드 개수에 비례하며, 시간 복잡도로 표현하면 O(n)이다.
<br>
<br>
배열과 달리 연결 리스트는 포인터를 이용하여 원소의 삽입 또는 삭제를 매우 빠르게 수행할 수 있다.
<br>
아래 다이어그램은 연결 리스트 중간에 새로운 원소를 삽입하는 동작을 나타내는 다이어그램이다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/92cc5117-d81c-4608-b686-facb05896661)

<br>

새로운 원소를 삽입하려면 일단 새로운 노드를 생성하고 각 노드의 next 포인터를 수정해야 한다.
<br>
먼저 새로 추가한 노드(i = 2)의 next 포인터가 다음 노드(i = 3)를 가리키게 만든다.
<br>
<br>
그리고 이전 노드(i = 1)의 next 포인터가 다음 노드(i = 3)를 가리키던 것을 제거하고, 새로운 노드(i = 2)를 가리키도록 설정한다.
<br>
<br>
이러한 방식으로 새로운 노드가 연결 리스트에 추가된다.
<br>
<br>
마찬가지로 기존 원소를 제거하려면 삭제할 원소가 더 이상 연결 리스트에 연결되어 있지 않도록 next 포인터를 수정하면 된다.
<br>
그 후 해당 노드의 메모리 할당을 해제하거나 또는 다른 적절한 처리를 수행할 수 있다.
<br>
<br>
연결 리스트에서는 원소가 메모리에 연속적으로 저장되지 않기 때문에 캐시 지역성을 기대할 수 없다.
<br>
즉, 현재 노드가 가리키는 다음 노드에 직접 방문하지 않고 다음 원소를 캐시로 가져올 수 있는 방법은 없다.
<br>
<br>
따라서 배열과 연결 리스트에서 모든 원소를 차례대로 방문하는 작업은 이론적으로 같은 시간 복잡도를 가지지만, 실제로는 연결 리스트의 성능이 조금 떨어진다.

### 1.2.3 비교

### 자료 구조 비교

|연속된 자료 구조|연결된 자료 구조|
|:---:|:---|
|모든 데이터가 메모리에 연속적으로 저장됨|데이터는 노드에 저장, 노드는 메모리 곳곳에 흩어져 있음|
|임의 원소에 즉각 접근 가능|임의 원소에 접근하는 것은 선형 시간 복잡도를 가지며 느린 편|
|캐시 지역성 효과로 인해 모든 데이터를 순회하는 것이 매우 빠름|캐시 지역성 효과가 없어 데이터를 순회하는 것이 느림|
|데이터 저장을 위해 정확하게 데이터 크기만큼의 메모리 사용|각 노드에서 포인터 저장을 위해 여분의 메모리 사용|

### 시간 복잡도

|파라미터|배열|연결 리스트|
|:---:|:---:|:---:|
|임의 접근|O(1)|O(n)|
|맨 뒤에 원소 삽입|O(1)|O(1)|
|중간에 원소 삽입|O(n)|O(1)|
|캐시 지역성|있음|없음|

<br>

### 1.2.4 C 스타일 배열의 제약 사항
C 스타일 배열은 몇 가지 제약 사항을 가지고 있으며, 아래는 C 스타일 배열의 단점이다.
- 메모리 할당과 해제를 수동으로 처리해야 하며, 메모리를 해제하지 못하면 메모리 릭(Memory Leak)이 발생할 수 있고, 이 경우 해당 메모리 영역을 사용할 수 없음
- [] 연산자에서 배열 크기보다 큰 원소를 참조하는 것을 검사하지 못하며 잘못하면 세그멘테이션 결험(Segmentation Fault) 또는 메모리 손상으로 이어짐
- 배열을 중첩해서 사용할 경우, 문법이 너무 복잡해서 코드를 이해하기 어려움
- 깊은 복사(Deep Copy)가 기본적으로 동작하지 않으모 이러한 동작은 수동으로 구현해야 함

<br>

## 1.3 std::array

std::array는 메모리를 자동으로 할당하고 해제한다.
<br>
std::array는 원소의 타입과 배열 크기를 매개변수로 사용하는 클래스 템플릿이다.
<br>
<br>
아래 예제는 크기가 10인 int 타입의 std::array 배열을 선언한 후 원소 값을 설정하거나 출력하는 예제 코드이다.

```
std::array<int, 10> arr1;    // 크기가 10인 int 타입 배열 선언

arr1[9] = 1;    // 첫 번째 원소를 1로 설정

std::cout << "arr1 배열의 첫 번째 원소 : " << arr1[0] << std::endl;

std::array<int, 4> arr2 = { 1, 2, 3, 4 };
std::cout << "arr2의 모든 원소: ";

for(int i = 0; i < arr2.size(); i++)
    std::cout << arr2[i] << " ";

std::cout << std::endl;

// 실행 결과
arr1 배열의 첫 번째 원소: 1
arr2의 모든 원소: 1 2 3 4
```

std::array는 C 스타일 배열과 똑같은 방식으로 배열 원소에 접근할 수 있는 [] 연산자를 제공한다.
<br>
[] 연산자에 접근하고자 하는 배열 원소 인덱스를 지정할 경우 빠른 동작을 위해 전달된 인덱스 값이 배열의 크기보다 작은지 검사하지 않는다.
<br>
<br>
대신 std::array는 at(index) 형식의 함수도 함께 제공하며, 이 함수는 인자로 전달된 index 값이 유효하지 않으면 std::out_of_range(exception)를 발생시킨다.
<br>
<br>
그러므로 at() 함수가 [] 연산자보다 조금 느린 편이지만, at() 함수를 잘 이용하면 예외를 적절하게 처리할 수 있다.
<br>
<br>
배열 인덱스를 사용자 입력으로 받거나 또는 다른 이유로 인해 유효하지 않은 인덱스에 접근할 수 있는 상황이라면 다음과 같은 예외 처리 코드를 만들 수 있다.

```
std::array<int, 4> arr3 = { 1, 2, 3, 4 };

try
{
    std::cout << arr3.at(3) << std::endl; // 에러 아님
    std::cout << arr3.at(4) << std::endl; // std::out_of_range 예외 발생
}

catch (const std::out_of_range& ex)
{
    std::cerr << ex.what() << std::endl;
}
```
std::array 객체를 다른 함수에 전달하는 방식은 기본 데이터 타입을 전달하는 것과 유사하다.
<br>
값 또는 참조(referene)로 전달할 수 있고, conts를 함께 사용할 수도 있다.
<br>
<br>
C 스타일 배열을 함수에 전달할 때처럼 포인터 연산을 사용한다거나 참조 또는 역참조(de-reference) 연산을 하지 않아도 된다.
<br>
그러므로 다차원 배열을 전달하는 경우에도 std::array를 사용하는 것이 가독성이 훨씬 좋다.
<br>
<br>
다음은 사용자 정의 함수 print()에 std::array 배열을 값으로 전달하는 예제 코드이다.

```
void print(std::array<int, 5> arr)
{
    for(auto ele : arr)
        std::cout << ele << ", ";
}

std::array<int, 5> arr = { 1, 2, 3, 4, 5 };
print(arr);

// 실행 결과

1, 2, 3, 4, 5,
```

이 print() 함수의 매개변수 데이터 타입에 전달받을 배열 크기가 고정되어 있기 때문에 다른 크기의 배열을 전달할 수 없다.
<br>
예를 들어 std::array<int, 10>을 전달하면 컴파일러는 함수 매개변수와 일치하지 않는다거나 또는 해당 매개변수를 형식으로 변환할 수 없다는 에러 메시지를 출력한다.
<br>
<br>
만약 다양한 크기에 대해 동작하는 함수를 만들려면 print()를 함수 템플릿으로 선언하고 배열 크기를 템플릿 매개변수로 전달하면 된다.
<br>
<br>
즉, 아래와 같은 형태로 작성한다.

```
template <size_t N>
void print(const std::array<int, N>& arr);
```

함수에 std::array 객체를 전달할 경우, 기본적으로 새로운 배열에 모든 원소가 복사된다.
<br>
즉, 자동으로 깊은 복사가 동작한다.
<br>
<br>
만약 이러한 동작을 피하고 싶다면 참조 또는 const 참조를 사용할 수 있다.
<br>
<br>
배열의 원소를 차례대로 접근하는 연산은 매우 자주 발생한다.
<br>
std::array는 반복자(iterator)와 범위 기반 for(range-based for) 문법을 이용하여 차례대로 접근할 수 있다.

```
std::array<int, 5> arr = { 1, 2, 3, 4, 5 };

for(auto element : arr)
{
    std::cout << element << ' ';
}

// 실행 결과
1 2 3 4 5
```

배열의 모든 원소를 차례대로 출력하기 위해 인덱스 값을 사용하는 for문을 사용할 수 있다.
<br>
이 경우에는 배열의 크기를 정확하게 지정해야 하며 인덱스 값이 배열 크기보다 같거나 커지면 에러가 발생한다.
<br>
<br>
std::array는 begin()과 end()라는 이름의 멤버 함수를 제공하며, 가장 첫 번째 원소와 마지막 원소의 위치를 반환한다.
<br>
특정 원소 위치에서 다음 원소 위치로 이동하려면 반복자에 증가 연산자(++) 또는 덧셈 연산자(+) 같은 산술 연산을 수행할 수 있다.
<br>
<br>
즉, 범위 기반 for 반복문은 begin() 위치부터 시작하여 증가 연산자(++)를 통해 차례대로 원소를 이동하다가 end() 위치에 도달하면 종료한다.
<br>
<br>
반복자는 std::array, std::vector, std::map, std::set, std::list 처럼 반복 가능한 STL 컨테이너에 대해 사용할 수 있다.
<br>
<br>
컨테이너 내부의 위치를 나타내는 데 필요한 모든 기능에 대해서도 반복자가 사용된다.
<br>
예를 들어 특정 위치에 원소를 삽입하거나, 특정 위치 또는 범위에 있는 원소를 삭제하는 등의 작업에서도 반복자가 사용된다.
<br>
반복자를 사용함으로써 소스 코드의 재사용성, 유지 보수, 가독성 측면에서 이점을 얻을 수 있다.
<br>
<br>
이제 범위 기반 반복문은 다음과 같이 바꿔서 사용할 수 있다.

```
for(auto it = arr.begin(); it != arr.end(); it++)
{
    autl element = (*it);
    std::cout << element << ' ';
}
```

const_iterator 또는 reverse_iterator 같은 형태의 반복자도 사용할 수 있다.
<br>
const_iterator 반복자는 일반 반복자의 const 버전이다.
<br>
<br>
const로 선언된 배열에 대해 begin() 또는 end() 같은 함수를 사용하면 const_iterator를 반환한다.
<br>
reverse_iterator를 사용하면 배열을 역방향으로 이동할 수 있다.
<br>
이 반복자를 ++ 같은 연산자와 함께 사용할 경우, 일반 반복자와 반대 방향으로 이동하게 된다.
<br>
<br>
[] 연산자와 at() 함수 외에 std::array에서 원소 접근을 위해 사용할 수 있는 멤버 함수는 다음과 같다.
- front() : 배열의 첫 번째 원소에 대한 참조 반환
- back() : 배열의 마지막 원소에 대한 참조 반환
- data() : 배열 객체 내부에서 실제 데이터 메모리 버퍼를 가리키는 포인터 반환

```
std:array<int, 5> arr = { 1, 2, 3, 4, 5 };
std::cout << arr.front() << std::endl;       // 1 출력
std::cout << arr.back() << std::endl;        // 5 출력
std::cout << *(arr.data() + 1) << std::endl; // 2 출력
```

std::array는 깊은 비교(Deep Comperison)를 위한 관계 연산자(Relational Operator)와 깊은 복사를 위한 복사 할당 연산자(Copy-Assignment Operator)도 지원한다.


<br>

### 1.3.1 연습 문제 1 :
