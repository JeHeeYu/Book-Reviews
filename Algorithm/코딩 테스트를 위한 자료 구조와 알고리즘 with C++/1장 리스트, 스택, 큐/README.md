# 1장 리스트 스택 큐 정리 내용

## 1-2. 연속된 자료 구조와 연결된 자료 구조
응용 프로그램에서 데이터를 처리하기 앞서 데이터를 어떻게 저장할 것인가를 결정해야 한다.
<br>
지연 시간, 사용 메모리, 또는 기타 매개변수 측면에서 최선의 성능을 제공하도록 구현 방법을 선택해야 한다.
<br>
<br>
어떠한 자료 구조를 선택할 것인가를 결정함에 있어 적합한 지표로 알고리즘 복잡도 또는 시간 복잡도(Time Complexity)가 있다.
<br>
<br>
시간 복잡도는 특정 작업을 수행하는 데 걸리는 시간을 데이터 크기에 대한 수식으로 표현하는 방식이다.
<br>
따라서 시간 복잡도는 데이터 크기가 변경되면 연산 시간이 어떻게 변하는지를 보여준다.
<br>
서로 다른 연산의 시간 복잡도는 그 내부에서 데이터를 어떻게 저장하여 사용하는가에 따라 달라진다.

### 1.2.1 연속된 자료 구조
연속된 자료 구조는 모든 원소를 단일 메모리 청크(Chunk)에 저장한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/7f2d1906-1901-4be4-935d-32872843741e)

<br>

바깥쪽 큰 사각형은 모든 원소가 저장되어 있는 단일 메모리 청크를 나타내고, 안쪽 작은 사각형들은 각각의 원소가 저장된 메모리 공간을 의미한다.
<br>
이 그림에서 각각의 원소는 모두 같은 타입을 사용한다.
<br>
그러므로 모든 원소는 같은 크기의 메모리를 사용하고, 이는 sizeof(type)으로 표시된다.
<br>
<br>
첫 번째 메모리 주소를 시작 주소(BA, Base Address)라고 한다.
<br>
<br>
모든 원소가 같은 타입이기 때문에 두 번째 원소의 위치는 BA + sizeof(type)이고, 그 다음 원소의 위치는 BA + 2 * sizeof(type)이 된다.
<br>
<br>
나머지 원소도 이와 같은 방식으로 계산할 수 있다.
<br>
즉, i 번째 원소에 접근하려면 BA + i * sizeof(type) 수식을 사용한다.
<br>
<br>
이러한 자료 구조에서는 배열의 전체 크기에 상관 없이 앞서 설명한 수식을 이용하여 모든 원소에 곧바로 접근할 수 있다.
<br>
따라서 데이터의 접근 시간은 항상 일정한데, 이러한 경우를 빅오(Big-O) 표기법으로 나타내면 O(1)로 표시한다.
<br>
<br>
배열의 유형은 크게 정적 배열(Static Array)과 동적 배열(Dynamic Array) 두 가지로 나눌 수 있다.
<br>
정적 배열은 선언된 블록이 끝나면 소멸되고, 동적 배열은 프로그래머가 자유롭게 결정한다.
<br>
<br>
정적 배열은 스택 메모리 여역에 할당되므로 함수가 종료되면 자동으로 해제된다.
<br>
반면 동적 배열은 힙 영역에 할당되며 사용자가 직접 해제하기 전까지 유지된다.
<br>
<br>
배열 같은 연속된 자료 구조에서 각 원소는 서로 인접해 있기 때문에 하나의 원소에 접근할 때 그 옆에 있는 원소 몇 개도 함께 캐시로 가져온다.
<br>
그러므로 다시 주변 원소에 접근하 ㄹ때 해당 원소를 캐시에서 가져오게 되며, 이 작업은 매우 빠르게 동작한다.
<br>
이러한 속성을 캐시 지역성(Cache Locality)이라고 한다.
<br>
<br>
어떤 연산의 점근적 시간 복잡도 계산에는 영향을 주지 않지만 실제 동작에는 배열처럼 연속된 원소에 매우 빠르게 접근할 수 있다는 점은 큰 장점이 된다.
<br>
배열에서 모든 원소에 순차적으로 접근하는 경우, 첫 번째 원소를 가져온 후 다음 원소는 캐시에서 바로 참조할 수 있으므로 배열은 캐시 지역성이 좋다고 말할 수 있다.

<br>

### 1.2.2. 연결된 자료 구조(Linked Data Structures)
연결된 자료 구조는 노드(Node)라고 하는 여러 개의 메모리 청크에 데이터를 저장하며, 이 경우 서로 다른 메모리 위치에 데이터가 저장된다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/275ef78d-26c4-4d3e-bb94-a24811eef7fc)


<br>

위와 같은 형태로 구성된 자료 구조를 연결 리스트(Linked List)라고 한다.
<br>
연결 리스트의 기본 구조에서 각각의 노드는 저장할 데이터와 다음 노드를 가리키는 포인터를 가지고 있다.
<br>
<br>
맨 마지막 노드에서는 다음 노드의 포인터 대신 자료 구조의 끝을 나타내는 NULL을 가진다.
<br>
<br>
연결 리스트에서 특정 원소에 접근하려면 리스트의 시작 부분, 즉 헤드 부분부터 시작하여 원하는 원소에 도달할 때까지 next 포인터를 따라 이동해야 한다.
<br>
그러므로 i 번째 원소에 접근하려면 연결 리스트 내부를 i번 이동하는 작업이 필요하다.
<br>
<br>
이때 원소 접근 시간은 노드 개수에 비례하며, 시간 복잡도로 표현하면 O(n)이다.
<br>
<br>
배열과 달리 연결 리스트는 포인터를 이용하여 원소의 삽입 또는 삭제를 매우 빠르게 수행할 수 있다.
<br>
아래 다이어그램은 연결 리스트 중간에 새로운 원소를 삽입하는 동작을 나타내는 다이어그램이다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/92cc5117-d81c-4608-b686-facb05896661)

<br>

새로운 원소를 삽입하려면 일단 새로운 노드를 생성하고 각 노드의 next 포인터를 수정해야 한다.
<br>
먼저 새로 추가한 노드(i = 2)의 next 포인터가 다음 노드(i = 3)를 가리키게 만든다.
<br>
<br>
그리고 이전 노드(i = 1)의 next 포인터가 다음 노드(i = 3)를 가리키던 것을 제거하고, 새로운 노드(i = 2)를 가리키도록 설정한다.
<br>
<br>
이러한 방식으로 새로운 노드가 연결 리스트에 추가된다.
<br>
<br>
마찬가지로 기존 원소를 제거하려면 삭제할 원소가 더 이상 연결 리스트에 연결되어 있지 않도록 next 포인터를 수정하면 된다.
<br>
그 후 해당 노드의 메모리 할당을 해제하거나 또는 다른 적절한 처리를 수행할 수 있다.
<br>
<br>
연결 리스트에서는 원소가 메모리에 연속적으로 저장되지 않기 때문에 캐시 지역성을 기대할 수 없다.
<br>
즉, 현재 노드가 가리키는 다음 노드에 직접 방문하지 않고 다음 원소를 캐시로 가져올 수 있는 방법은 없다.
<br>
<br>
따라서 배열과 연결 리스트에서 모든 원소를 차례대로 방문하는 작업은 이론적으로 같은 시간 복잡도를 가지지만, 실제로는 연결 리스트의 성능이 조금 떨어진다.

### 1.2.3 비교

### 자료 구조 비교

|연속된 자료 구조|연결된 자료 구조|
|:---:|:---|
|모든 데이터가 메모리에 연속적으로 저장됨|데이터는 노드에 저장, 노드는 메모리 곳곳에 흩어져 있음|
|임의 원소에 즉각 접근 가능|임의 원소에 접근하는 것은 선형 시간 복잡도를 가지며 느린 편|
|캐시 지역성 효과로 인해 모든 데이터를 순회하는 것이 매우 빠름|캐시 지역성 효과가 없어 데이터를 순회하는 것이 느림|
|데이터 저장을 위해 정확하게 데이터 크기만큼의 메모리 사용|각 노드에서 포인터 저장을 위해 여분의 메모리 사용|

### 시간 복잡도

|파라미터|배열|연결 리스트|
|:---:|:---:|:---:|
|임의 접근|O(1)|O(n)|
|맨 뒤에 원소 삽입|O(1)|O(1)|
|중간에 원소 삽입|O(n)|O(1)|
|캐시 지역성|있음|없음|
