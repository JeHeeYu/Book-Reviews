## 2.4 다양한 트리 구조

### 2.4.1 이진 검색 트리(BST, Binary Search Tree)
이진 검색 트리는 널리 사용되는 형태의 트리로, 다음과 같은 속성이 있다.
- 부모 노드의 값 >= 왼쪽 자식 노드의 값
- 부모 노드의 값 <= 오른쪽 자식 노드의 값

즉, (왼쪽 노드 <= 부모 노드 <= 오른쪽 노드)의 관계를 가진다.
<br>
<br>
이러한 관계식은 부모 노드보다 작거나 같은 모든 원소는 항상 왼쪽에, 부모 노드보다 크거나 같은 원소는 항상 오른쪽에 있게 된다.
<br>
따라서 원소 검색을 위해 루트 노드부터 차례대로 값을 비교하는 경우, 각 단계마다 검색 범위가 절반으로 줄어든다.
<br>
<br>
BST가 마지막 레벨을 제외한 모든 노드에 두 개의 자식 노드가 있을 경우 이 트리의 높이는 log(2)N이 된다.
<br>
여기서 N은 원소의 개수를 나타낸다.
<br>
<br>
이로 인해 BST의 검색 및 삽입 동작은 O(log N)의 시간 복잡도를 갖는다.
<br>
이러한 형태의 이진 트리를 완전 이진 트리(Complete Binary Tree)라고 한다.

<br>

### BST에서 원소 검색
예를 들어 아래와 같이 중복되지 않는 양수를 원소로 갖는 트리가 있으며, 7을 찾으려고 한다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/e94efa5c-1e4e-4c8c-9f45-e01b31dd1cde)

<br>

화살표로 표현된 것처럼 각 노드의 숫자와 7을 비교하여 어느 하위 노드로 이동할지를 결정해야 한다.
<br>
이진 검색 트리에서 현재 노드보다 왼쪽 노드는 값이 작고, 오른쪽 노드는 값이 크다는 점이 중요하다.
<br>
<br>
먼저 루트 노드와 숫자 7을 비교한다.
<br>
루트 노드의 값은 12인데, 7은 12보다 작으므로 왼쪽 자식 노드로 이동한다.
<br>
이후 왼쪽 자식 노드의 값은 10인데, 7은 10보다 작으므로 다시 왼쪽 자식 노드로 이동한다.
<br>
<br>
이후 같은 작업을 진행하다가 4 노드에서 왼쪽 노드는 2이므로 오른쪽 노드를 검색하면 숫자 7을 찾을 수 있다.
<br>
<br>
BST에서 원소를 검색할 때 트리의 모든 원소를 방문하지 않아도 된다.
<br>
현재 노드가 찾고자 하는 노드가 아닐 때마다 검색 범위가 반으로 줄어든다.

<br>


### BST에 새 원소 삽입하기
위와 같은 트리 구조에서 18을 추가하려고 한다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/f462bf90-dfbb-4b1f-a0bf-d639ca4b1995)

<br>

새로운 원소를 추가하려면 먼저 원소가 삽입될 위치의 부모 노드를 찾아야 한다.
<br>
즉, 루트 노드부터 각 노드를 추가할 원소와 비교하면서 원소가 삽입될 위치로 이동해야 한다.
<br>
<br>
위 그림과 같이 새 원소 18을 추가하기 위해 먼저 17이 저장된 노드까지 이동했으며, 18이 17보다 크므로 17의 오른쪽 자식 노드에 18을 추가한다.

<br>

### BST에서 원소 삭제하기
아래와 같은 트리가 있다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/e11edf35-0612-4f14-8211-c7822a802a94)

<br>

이 트리에서 루트 노드 12를 삭제하려고 한다.
<br>
BST에서 원소를 삭제하는 작업은 단순히 노드를 삭제하는 것으로 끝나는 것이 아니라, 노드 삭제 후 전체 트리가 BST 속성을 만족하도록 다른 적절한 노드로 삭제된 노드를 대체해야 하기 때문에 복잡하다.
<br>
<br>
먼저 첫 번째 단계로 삭제할 노드를 찾아야 하며, 그 후 다음과 같은 세 가지 경우를 확인해야 한다.
- 자식 노드가 없는 경우 : 단순히 해당 노드를 삭제하면 됨
- 자식 노드가 하나만 있는 경우 : 노드 삭제 후, 부모 노드의 포인터가 해당 자식 노드를 가리키도록 조정
- 자식 노드가 두 개 있는 경우 : 노드 삭제 후, 현재 노드를 후속 노드(Successor)로 대체

여기서 후속 노드란 현재 노드 다음으로 큰 숫자를 가진 노드를 말한다.
<br>
즉, 현재 원소보다 큰 원소들 중에서 가장 작은 원소를 의미한다.
<br>
<br>
따라서 현재 노드의 오른쪽 서브 트로 이동 후, 여기서 가장 작은 값의 노드를 찾으면 된다.
<br>
가장 작은 노드를 찾으려면 서브 트리에서 가장 왼쪽에 위치한 노드로 이동하면 된다.

<br>

### 2.4.2 트리 연산의 시간 복잡도
트리 연산에서 시간 복잡도는 검색의 경우 이론적으로 매번 검색 범위가 절반으로 줄어든다고 할 수 있다.
<br>
그러므로 N개의 노드를 가지고 있는 BST에서 검색에 필요한 시간은 T(N) = T(N / 2) + 1 수식으로 표현할 수 있다.
<br>
수식을 시간 복잡도로 표현하면 T(N) = O(log N)이다.
<br>
<br>
그러나 여기서 삽입 함수를 잘 분석해보면 트리의 모양이 원소 삽입 순서에 따라 결정된다는 점을 알 수 있다.
<br>
그리고 검색 범위가 수식처럼 T(N / 2) 형태로 줄어드는 것도 항상 성립되지 않는다.
<br>
그러므로 시간 복잡도가 O(log N)이라는 것도 항상 정확하다고 볼 수 없다.

<br>

### 2.4.3 연습 문제 9 : [BST 구현하기](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC%20%EC%9C%84%ED%95%9C%20%EC%9E%90%EB%A3%8C%20%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20with%20C%2B%2B/2%EC%9E%A5%20%ED%8A%B8%EB%A6%AC%2C%20%ED%9E%99%2C%20%EA%B7%B8%EB%9E%98%ED%94%84/2.4%20%EB%8B%A4%EC%96%91%ED%95%9C%20%ED%8A%B8%EB%A6%AC%20%EA%B5%AC%EC%A1%B0/BST.cpp)

<br>

### 실행 결과

```
중위 순회 : 2 4 8 10 11 12 15 20 28 
12를 삭제한 후 중위 순회 : 2 4 8 10 11 15 20 28 
15에서 왼쪽으로 이동 : 10에서 오른쪽으로 이동 : 11에서 오른쪽으로 이동 : 
원소 12는 트리에 없습니다.
```

<br>

### 2.4.4 균형 트리

예를 들어 먼저 BST에 다음과 같은 순서로 원소를 삽입한다.
```
bst tree;
tree.insert(10);
tree.insert(9);
tree.insert(11);
tree.insert(8);
tree.insert(7);
tree.insert(6);
tree.insert(5);
tree.insert(4);
```

이렇게 구성된 BST를 그림으로 표현하면 다음과 같다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/04b9d213-1ca2-44e0-b289-28048522205e)

<br>

이 그림을 보면 전체 트리가 왼쪽으로 편향되어 있는 것을 볼 수 있다.
<br>
이 상태에서 트리의 find() 함수를 사용하여 bst.find(4) 코드를 실행하면 아래와 같은 형태로 검색을 수행한다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/b06b3106-8c5f-4acc-b131-596b3812a49e)

<br>

이 경우 비교 횟수가 원소 개수와 거이 같아진다.
<br>
이번에는 다른 예를 들기 위해 아래와 같이 BST를 만든다.
```
bst tree;
tree.insert(7);
tree.insert(5);
tree.insert(9);
tree.insert(4);
tree.insert(6);
tree.insert(10);
tree.insert(11);
tree.insert(8);
```

이와 같은 트리를 그림으로 표현하면 다음과 같다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/3743782d-4bee-4efd-a3bb-dd4fb3aa3cc1)

<br>

이 트리는 편향되지 않은 상태인데, 이러한 트리를 균형이 잡혔다고 한다.
<br>
이 상태에의 트리에서는 4를 찾는 단계가 크게 감소한다.
<br>
<br>
즉, find() 함수의 시간 복잡도는 단순히 원소 개수에만 영향을 받는 것이 아니라 트리의 형태에 대해서도 영항을 받는다.
<br>
<br>
검색 단계를 면밀히 살펴보면 항상 트리의 아래쪽으로 한 단계씩 나아가는 것을 알 수 있다.
<br>
그리고 결국 더 이상 자식 노드가 없는 리프 노드(Leaf Node)에서 끝나게 된다.
<br>
<br>
여기서 찾고자 하는 원소를 발견하면 해당 노드를 반환하고, 없으면 NULL을 반환한다.
<br>
따라서 검색에 필요한 단계의 수는 BST의 최대 레벨 수보다도 작다.
<br>
<br>
BST의 레벨 수를 BST의 높이(height)라고 부르기 때문에 원소 검색의 실제 시간 복잡도는 O(높이)로 표현할 수 있다.
<br>
<br>
결국 원소 검색의 시간 복잡도를 최적화하려면 트리의 높이가 최적화되어야 한다.
<br>
이러한 작업을 트리의 균형 잡기라고 한다.
<br>
트리의 균형을 잡기 위해서는 원소 삽입 또는 삭제 후에 트리 구성을 조정해야 한다.
<br>
<br>
이렇게 조정되어 편향성이 줄어든 이진 검색 트리를 높이-균형 BST(Height-Balance) 라고 한다.

<br>


### 2.4.5 N-항 트리
N-항 트리(N-ary Tree)는 각 노드가 N개의 자식을 가질 수 있다.
<br>
N은 임의의 양수이므로 N개의 자식 노드는 벡터를 이용하여 저장할 수 있다.
<br>
<br>
N항 트리는 다음과 같이 구현한다.
```
struct nTree
{
    int data;
    std::vector<nTree*> children;
};
```
이 코드에서 각각의 노드는 임의 개수의 자식을 거느릴 수 있다.
<br>
그러므로 전체 트리도 임의의 형태를 가지게 된다.
<br>
<br>
컴퓨터 분야에서 N항 트리를 사용하는 대표적인 예는 다음과 같다.
- 컴퓨터 파일 시스템 구조
- 컴파일러

<br>
