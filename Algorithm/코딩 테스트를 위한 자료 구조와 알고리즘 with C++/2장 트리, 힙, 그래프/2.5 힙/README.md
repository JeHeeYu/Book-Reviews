## 2.5 힙

힙은 다음과 같은 시간 복잡도를 만족해야 한다.
- O(1) : 최대 원소에 즉각적으로 접근할 수 있어야 함
- O(log N) : 원소 삽입에 대한 시간 복잡도
- O(log N) : 최대 원소 삭제에 대한 시간 복잡도

원소 삽입 또는 삭제에 대해 O(log N)의 시간 복잡도를 만족하기 위해 트리 구조를 사용해야 한다.
<br>
다만 이 경우에는 특히 완전 이진 트리를 사용해야 한다.
<br>
<br>
완전 이진 트리는 마지막 레벨의 노드를 제외하고는 모두 두 개의 자식 노드가 있고, 마지막 레벨에서는 왼쪽부터 차례대로 노드가 있는 트리이다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/0c851afc-2d0f-4757-8190-05748b11c650)


<br>

완전 이진 트리는 새로운 원소를 트리의 마지막 레벨에 추가하는 방식으로 구성할 수 있다.
<br>
만약 마지막 레벨의 모든 노드가 채워져 있다면 새로운 레벨을 하나 더 만들고, 맨 왼쪽 위치에 노드를 추가한다.
<br>
<br>
완전 이진 트리는 트리의 데이터를 배열을 이용하여 저장할 수 있다.
<br>
즉, 루트 노드를 배열 또는 벡터의 맨 처음에 저장하고, 그다음 레벨의 모든 노드는 왼쪽부터 오른쪽 순서로 저장한다.
<br>
<br>
이러한 방식의 완전 이진 트리 표현은 다른 노드를 가리키는 포인터를 저장할 필요가 없기 때문에 메모리 사용 측면에서 효율적이다.
<br>
부모 노드로부터 자식 노드로 이동하는 것은 단순히 배열의 인덱스 계산으로 가능하다.
<br>
<br>
만약 부모 노드가 i번째 배열 원소로 저장되어 있다면 자식 노드는 2xi + 1 또는 2xi + 2 번째 인덱스로 접근하면 된다.
<br>
마찬가지로 자식 노드가 i번째 인덱스라면 부모 도느는 (i-1) / 2 번째 인덱스이다.
<br>
<br>
그리고 원소를 삽입하거나 삭제할 때 유지해야 하는 힙의 불변성(Inveriants) 또는 조건이 있다.
<br>
첫 번째 조건은 최대 원소에 즉각적으로 접근 가능해야 한다는 점이다.
<br>
이를 위해 최대 원소가 항상 고정된 위치에 있어야 한다.
<br>
<br>
힙을 구현할 때는 항상 최대 원소가 트리의 루트에 있도록 설정한다.
<br>
이를 위해 부모 노드가 두 자식 노드보다 항상 커야 한다는 불변성을 유지하도록 설정해야 한다.
<br>
이렇게 구성한 힙을 최대 힙(Max Heap)이라고 한다.
<br>
<br>
최대 원소에 빠르게 접근할 수 있다면 반대로 최소 원소에 빠르게 접근할 수 있도록 힙을 구성할 수도 있다.
<br>
이러한 힙을 만들려면 앞서 설명한 설명의 비교 연산을 반대로 설정하면 되며, 이렇게 만들어진 힙을 최소 힙(Min Hea)이라고 한다.

<br>

### 2.5.1 힙 연산

### 힙에 원소 삽입하기
힙의 가장 중요한 불변성은 완전 이진 트리를 유지해야 한다는 점이다.
<br>
완전 이진 트리를 유지하고 있어야 배열 자료 구조를 이용하여 힙을 저장할 수 있다.
<br>
<br>
완전 이진 트리를 유지하는 힙에 새 원소를 삽입하려면 단순히 배열의 맨 마지막 위치에 원소를 추가하면 된다.
<br>
이 작업은 기존 트리의 마지막 레벨, 마지막 노드 바로 오른쪽에 새로운 노드를 추가하는 것과 같다.
<br>
만약 마지막 레벨이 꽉 차 있다면 새로운 레벨을 추가하여 노드를 추가한다.
<br>
<br>
이 조건 말고 다른 불변 조건도 있다.
<br>
모든 노드는 자식보다 더 큰 값을 가지고 있어야 한다.
<br>
일단 기존의 트리는 이미 이 불변 조건을 만족하고 있다고 가정한다.
<br>
<br>
그러나 새로운 원소를 트리의 맨 마지막 위치에 추가한 후에는 이 조건이 성립되지 않을 가능성이 생긴다.
<br>
이를 해결하기 위해 새로 삽입한 원소의 부모 노드와 값을 비교하고, 만약 부모 노드가 더 작으면 서로 교환한다.
<br>
만약 부모 노드에 다른 자식 노드가 있다 하더라도 이 자식 노드는 새로 추가한 원소보다 작다.
<br>
<br>
그러므로 새로 추가한 원소를 루트 노드로 간주하는 서브 트리는 힙 불변성을 만족하게 된다.
<br>
<br>
그러나 새 원소가 여전히 새 부모 노드보다 큰 값을 가질 수 있다.
<br>
따라서 전체 트리에서 불변 조건이 만족하도록 교환 작업을 반복해야 한다.
<br>
완전 이진 트리의 높이는 최대 log N이므로, 삽입 연산의 시간 복잡도는 O(log N)으로 표현할 수 있다.
<br>
아래 그림은 힙의 삽입 연산 동작이다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/e57b19bd-a714-448e-9aa4-aec298e8343a)

<br>

위 그림에서 11을 맨 마지막에 추가한 후에는 힙의 속성을 만족하지 못하게 된다.
<br>
그러므로 원소 10과 11을 서로 교환해야 한다.
<br>
<br>
아래 그림은 위와 같은 동작을 여러 레벨어 걸쳐서 수행하는 과정이다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/be429b81-6bf7-44c7-8ee8-300fa2144c47)

<br>

### 힙에서 원소 삭제하기
일단 힙에서는 가장 큰 원소만 삭제할 수 있다.
<br>
그 이유는 다른 원소에는 직접 접근할 수 없기 때문이다.
<br>
<br>
최대 원소는 항상 트리의 루트에 존재하므로, 루트 노드를 삭제해야 한다.
<br>
루트를 삭제할 경우, 어느 노드를 이용하여 루트를 대체할 것인가를 결정해야 한다.
<br>
이를 위해 먼저 루트 노드와 트리의 맨 마지막 노드를 서로 교환한 후, 마지막 노드를 삭제한다.
<br>
<br>
이렇게 하면 최대 원소를 삭제한 것이 되며, 다만 루트 위치에서 부모 노드가 자식 노드보다 커야 한다는 불변성을 만족하지 못하게 된다.
<br>
이 문제를 해결하기 위해 루트 노드와 두 자식 노드를 서로 비교하여 그중 더 큰 노드와 서로 교환한다.
<br>
이렇게 하면 루트 노드와 두 서브 트리 중 하나에 대해 불변 규칙이 깨진 상태가 된다.
<br>
<br>
그러므로 서브 트리에 대해서도 노드 교환 작업을 재귀적으로 반복한다.
<br>
이러한 방식으로 불변성을 만족하지 못하는 위치가 점차 트리 아래쪽으로 이동하게 된다.
<br>
교환 작업의 최대 횟수는 트리의 높이와 같으므로 원소 삭제의 시간 복잡도는 O(log N)으로 표현할 수 있다.
<br>
<br>
아래 그림이 원소 삭제 과정을 나타낸 그림이다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/d5845a10-4b1f-4a36-9a83-dbc0ffcc1f11)

<br>

### 힙 초기화하기
힙에서 중요한 연산 중 하나인 힙 초기화는 벡터, 리스트, 덱과는 달리 힙의 불변성을 유지해야 하기 때문에 초기화가 간단하지 않다.
<br>
가장 간단한 해결책은 비어 있는 힙에 하나씩 원소를 삽입하는 것이다.
<br>
그러나 이 작업은 O(N log N)의 시간 복잡도를 가지며 효율적이지 않다.
<br>
<br>
그러나 힙 생성 알고리즘을 사용하면 O(N) 시간에 힙을 초기화할 수 있다.
<br>
이 알고리즘의 기본 개념은 간단한데, 전체 트리의 아래쪽 서브 트리부터 힙 불변 속성을 만족하도록 힙을 업데이트하는 방식이다.
<br>
<br>
먼저 맨 마지막 레벨은 자식 노드가 없으므로 이미 힙 속성을 만족한다고 간주한다.
<br>
그리고 한 레벨씩 트리 위로 올라가면서 힙 속성을 만족하도록 트리를 업데이트한다.
<br>
<br>
이 작업은 O(N)의 시간 복잡도를 갖는다.
<br>
C++ 표준은 배열 또는 벡터의 반복자를 인자로 받아 힙을 구성하는 std::make_heap() 함수를 제공한다.
