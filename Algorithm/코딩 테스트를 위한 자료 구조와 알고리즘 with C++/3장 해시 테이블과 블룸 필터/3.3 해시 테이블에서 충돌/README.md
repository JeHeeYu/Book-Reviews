# 3.3 해시 테이블에서 충돌

### 3.3.1 체이닝(Chaining)
체이닝은 두 값을 모두 저장할 수 있는 여러 방법 중 하나이다.
<br>
이 방법은 해시 테이블의 특정 위치에 하나의 키를 저장하는 것이 아니라 하나의 연결 리스트를 저장한다.
<br>
<br>
그러므로 새로 삽입된 키에 의해 충돌이 발생하면 리스트의 맨 뒤에 새로운 키를 추가한다.
<br>
따라서 다수의 원소를 원하는 만큼 저장할 수 있다.
<br>
<br>
벡터 대신 연결 리스트를 사용하는 이유는 특정 위치의 원소를 빠르게 삭제하기 위함이다.
<br>

### 연습 문제 14 : [체이닝을 사용하는 해시 테이블](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC%20%EC%9C%84%ED%95%9C%20%EC%9E%90%EB%A3%8C%20%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20with%20C%2B%2B/3%EC%9E%A5%20%ED%95%B4%EC%8B%9C%20%ED%85%8C%EC%9D%B4%EB%B8%94%EA%B3%BC%20%EB%B8%94%EB%A3%B8%20%ED%95%84%ED%84%B0/3.3%20%ED%95%B4%EC%8B%9C%20%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90%EC%84%9C%20%EC%B6%A9%EB%8F%8C/hash_map_chaining.cpp)

<br>

### 실행 결과

```
2을(를) 삽입했습니다.
25을(를) 삽입했습니다.
10을(를) 삽입했습니다.
100을(를) 삽입했습니다.
55을(를) 삽입했습니다.
해시 맵에서 100을(를) 찾았습니다.
해시 맵에서 2을(를) 찾았습니다.
25을(를) 삭제했습니다.
```

이 예제에서는 리스트를 이용하여 다수의 값을 저장할 수 있기 때문에 갚을 덮어쓰는 현상이 발생하지 않는다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/293cee88-242c-4d7d-92ee-b4885679a971)

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/e92db9b7-cc86-4c36-ab27-d8379fa49190)

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/7b6f59a8-31ad-4787-914e-4f787a1135fb)

<br>

위 예제에서 특정 해시 값 위치에 하나의 원소만 저장되는 것이 아니라 여러 개의 원소가 리스트 형태로 저장된다.
<br>
<br>
시간 복잡도를 보면, 삽입 함수의 경우는 O(1)이다.
<br>
리스트에 노드를 추가하는 연산이 단순히 값을 설정하는 것보다는 조금 느릴 수 있지만, 심하게 느리지는 않다.
<br>
체이닝을 통해 얻을 수 있는 이점에 비하면 무시할 수 있는 수준이다.
<br>
<br>
다만 검색과 삭제는 데이터 크기와 해시 테이블 크기에 따라 상당히 느릴 수 있다.
<br>
<br>
예를 들어 모든 키가 같은 해시 값을 가질 경우, 검색 연산은 연결 리스트에서 선형 검색을 수행하는 것과 같으므로 O(N)의 시간 복잡도를 갖게 된다.
<br>
만약 해시 테이블이 저장할 키 개수에 비해 매우 작다면 충돌이 많이 발생하게 되고, 리스트는 평균적으로 더 길어진다.
<br>
<br>
반면에 너무 큰 해시 테이블을 가지고 있다면 실제 데이터는 듬성듬성 존재하게 되므로 메모리 낭비가 심해진다.
<br>
그러므로 응용 프로그램의 동작 시나리오를 고려해서 해시 테이블 크기를 적절하게 조절해야 한다.
<br>
<br>
이를 위해 하나의 수식을 정의할 수 있다.
```
부하율(Load Factor) : 해시 테이블에서 각각의 리시트에 저장되는 키의 평균 개수

부하율 = 전체 키 개수 / 해시 테이블 크기
```

만약 키 개수가 해시 테이블 크기와 같다면 부하율은 1이다.
<br>
이는 매우 이상적인 상태로, 모든 연산이 O(1)에 가깝게 작동하고 모든 메모리 공간을 적저라게 활용한다.
<br>
<br>
부하율이 1보다 작으면 리스트당 키가 하나도 저장되지 않은 경우가 있다는 뜻이고, 이는 메모리 낭비가 될 수 있다.
<br>
만약 부하율이 1보다 크면 이는 리스트의 평균 길이가 1보다 크다는 의미이고, 이 경우 검색, 삭제 등의 함수가 약간 느리게 동작할 수 있다.
<br>
<br>
부하율은 항상 O(1) 시간 복잡도로 계산할 수 있다.
<br>
몇몇 해시 테이블은 부하율이 1 근방의 특정 값보다 너무 크거나 작아지면 해시 함수를 변경하도록 구현되어 있으며, 이를 재해싱(Rehashing)이라고 한다.
<br>
<br>
즉, 해시 함수를 수정하여 부하율이 1에 가까운 값이 되도록 만드는 것이다.
<br>
변경된 해시 함수에 의한 값의 분포와 부하율을 고려하여 해시 테이블의 크기도 변경할 수 있다.
<br>
<br>
그러나 부하율이 해시 테이블의 성능을 결정하는 유일한 지표는 아니다.
<br>
크기가 7인 해시 테이블에 일곱 개의 원소가 저장되어 있다고 가정해본다.
<br>
<br>
그런데 모든 원소가 같은 해시 값을 가져서 하나의 버킷(Bucket)에 있다.
<br>
그래서 검색 연산이 항상 O(1)이 아닌 O(N)의 시간 복잡도를 갖는다.
<br>
<br>
그렇지만 부하율은 1로 계산되고, 이는 매우 이상적인 상태로 인식될 수 있다.
<br>
결국 이러한 경우에는 해시 함수가 문제이다.
<br>
해시 함수는 서로 다른 키가 가급적이면 서로 겹치지 않고 골고루 분포되도록 해시 값을 만들어야 한다.
<br>
<br>
기본적으로 버킷의 최대 크기와 최소 크기의 차이가 너무 크면 좋지 않다.
<br>
지금 상황에서의 에에서는 버킷의 크기 차이가 7이다.
<br>
<br>
만약 해시 함수가 전체 일곱 개의 원소에 대해 서로 다른 해시 값을 반환한다면 검색 함수의 시간 복잡도는 O(1)이 되어 즉각적으로 결과를 반환할 수 있게 된다.
<br>
그리고 이때의 최대, 최소 크기의 버킷 크기 차이는 0이다.
<br>
<br>
그러나 이렇게 만드는 작업은 해시 테이블 구현에서 수행되지 않는다.
<br>
해시 테이블은 해시 함수 구현에 종속적이지 않기 때문에 해시 함수 자체에서 잘 고려해야 한다.

<br>


### 3.3.3 열린 주소 지정
충돌을 해결하는 다른 방법으로 열린 주소 지정(Open Addressing)이 있다.
<br>
이 방법은 체이닝처럼 해시 테이블에 추가적인 리스트를 붙여서 데이터를 저장하는 방식이 아닌, 모든 원소를 해시 테이블 내부에 저장하는 방식이다.
<br>
<br>
그러므로 해시 테이블의 크기가 반드시 데이터 개수보다 커야 한다.
<br>
열린 주소 지정 방법의 핵심은 특정 해시 값에 해당하는 위치가 이미 사용되고 있다면 테이블의 다른 비어 있는 위치를 탐색하는 것이다.
<br>
이때 다른 비어 있는 위치를 찾는 방법은 여러 가지가 있을 수 있다.

<br>


### 선형 탐색(Linear Probing)
선형 탐색은 가장 간단한 탐색 방법이다.
<br>
선형 탐색은 특정 해시 값에서 충돌이 발생하면 해당 위치에서 하나씩 다음 셀(Cell) 위치로 이동하면서 셀이 비어 있는지를 확인하고, 비어 있는 셀을 찾으면 원소를 삽입한다.
<br>
<br>
즉, hash(x)에 해당하는 셀이 이미 채워져 있다면 hash(x + 1) 위치의 셀을 확인한다.
<br>
만약 hash(x + 1) 셀도 사용 중이라면 다시 hash(x + 2) 셀을 검사한다.
<br>
아래 그림은 선형 탐색을 사용하는 해시 테이블의 삽입 및 검색 동작이다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/e06bf484-5a93-4441-b084-b928451874d4)

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/6fbdea72-1051-4bbb-96ff-4684014692ad)

<br>

주어진 데이터의 해시 값에 해당하는 위치가 이미 다른 값으로 채워져 있다면 다음으로 비어 있는 위치에 새 데이터를 삽입한다.
<br>
위 그림에서 처음에 세 개의 원소를 삽입했더니 해시 테이블의 특정 위치에 서로 인접한 군집 형태로 값이 채워졌다.
<br>
<br>
만약 이 구간에서 해시 값을 갖는 새 원소가 들어오면 이 군집은 더욱 커지게 된다.
<br>
만약 원소 검색을 할 경우, 해시 함수에서 반환한 위치가 큰 군집의 시작 위치를 가리킨다면 클러스터의 맨 마지막 위치까지 선행 검색을 해야 한다.
<br>
<br>
그러므로 검색 속도가 크게 느려질 수 있다.
<br>
<br>
즉, 데이터가 특정 위치에 군집화(Clustering)되는 경우에 문제가 발생하게 된다.
<br>
데이터가 군집화된다는 것은 특정 해시 값이 너무 자주 발생해서 데이터가 몇 개의 그룹으로 뭉치는 형태로 저장된다는 의미이다.
<br>
<br>
예를 들어 크기가 100인 해시 테이블이 있는데, 대부분의 키가 3에서 7 사이의 해시 값으로 변환된다고 한다.
<br>
이 경우 대부분의 데이터가 3 ~ 7 이 후 위치에 차례대로 저장될 것이고, 이로 인해 검색 속도는 급격하게 느려지게 된다.

<br>

### 이차함수 탐색(Quadratic Probing)
선형 탐색의 가장 큰 문제는 군집화인데, 충돌이 발생하면 군집을 차례대로 검사해야 하기 때문이다.
<br>
이를 해결하기 위해 선형 방정식이 아닌 이차 방정식을 사용하여 탐색을 수행할 수 있다.
<br>
이러한 방식의 탐색을 이차함수 탐색이라고 한다.
<br>
<br>
예를 들어 데이터 x를 hash(x) 위치에 삽입하려고 한다.
<br>
만약 이 위치가 이미 사용 중이라면 hash(x + 1^2)으로 이동하고, 그 다음은 hash(x + 2^2)으로 이동한다.
<br>
이처럼 이동 폭을 이차함수 형태로 증가시키면 데이터 군집이 나타날 확률은 상대적으로 줄어든다.
<br>
<br>
선형 탐색 및 이차 함수 탐색은 모두 원소 위치가 기존에 삽입되어 있는 다른 원소들에 의해 영향을 받는다.
<br>
이때 기존에 저장되어 있던 원소는 새로 삽입한느 원소와 서로 다른 해시 값을 가질 수도 있다.
<br>
<br>
즉, 특정 해시 값을 갖는 키가 오직 하나만 존재한다 하더라도 충돌이 발생할 수 있다.

<br>

### 3.3.4 뻐꾸기 해싱(Cuckoo Hashing)
뻐구기 해싱은 완벽한 해싱 기법 중 하나이다.
<br>
뻐꾸기 해싱은 구현만 제대로 한다면 최악의 상황에서도 O(1)을 만족한다.
<br>
<br>
뻐꾸기 해싱은 크기가 같은 두 개의 해시 테이블을 사용하고, 각각의 해시 테이블은 서로 다른 해시 함수를 가진다.
<br>
모든 원소는 두 해시 테이블 중 하나에 있을 수 있으며, 그 위치는 해당 해시 테이블의 해시 함수에 의해 결정된다.
<br>
뻐꾸기 해싱이 다른 해싱 기법과 다른 점은 다음과 같다.
- 원소가 두 해시 테이블 중 어디든 저장될 수 있음
- 원소가 나중에 다른 위치로 이동할 수 있음

뻐꾸기 해싱 방법에서는 모든 원소가 두 개의 저장 가능한 위치를 가지며, 상황에 따라 이동할 수 있다.
<br>
<br>
뻐꾸기 해싱에서 검색의 경우 특정 원소가 존재하는지를 알기 위해 저장 가능한 위치 두 군데만 확인하면 된다.
<br>
그러므로 룩업 연산의 시간 복잡도는 항상 O(1)이다.
<br>
<br>
그러나 삽입 연산은 좀 더 오래 걸릴 수 있다.
<br>
예를 들어 A라는 원소를 삽입한다고 가정한다.
<br>
<br>
삽입 함수는 먼저 첫 번째 해시 테이블에서 A를 삽입할 위치를 찾아 현재 비어 있는지를 검사한다.
<br>
만약 해당 위치가 비어 있다면 그대로 A를 삽입하면 된다.
<br>
<br>
그러나 해당 위치에 이미 다른 원소 B가 저장되어 있다면, 해당 위치에 A를 저장하고 B를 두 번째 해시 테이블로 옮긴다.
<br>
만약 B가 이동할 위치에 다른 원소 C가 저장되어 있다면, 해당 위치에 B를 저장하고 C를 첫 번째 해시 테이블로 옮긴다.
<br>
<br>
이러한 작업을 완전히 비어 있는 셀이 나타날 때까지 재귀적으로 반복한다.
<br>
이 과정들을 그림으로 나타낸 것이 아래 그림이다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/502d0ce5-78d1-4e1f-ac03-cad3fdf5dae2)

<br>

이러한 과정에서 만약 순환(Cycle)이 발생한다면 무한 루프에 빠질 수 있다.
<br>
예를 들어 위 그림에서 C가 옮겨가야 할 위치에 다른 원소 D가 있고, D를 옮기다 보니 다시 A위치를 방문한다고 가정한다.
<br>
<br>
이러한 경우가 순환이 발생하는 경우이며, 아래 그림과 같은 상황이다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/1f982568-6483-45da-be60-ab50069d0457)

<br>

일단 순환이 발생했다면 새로운 해시 함수를 이용하여 재해싱을 수행해야 한다.
<br>
새로운 해시 함수를 사용하여 해시 테이블을 새로 구성한 경우에도 다시금 순환이 발생할 수 있으므로 여러 번 재해싱을 수행해야 할 수도 있다.
<br>
<br>
그러나 적절한 해시 함수를 사용하면 높은 확률로 O(1)의 성능을 갖는 해시 테이블을 구섷알 수 있다.

<br>

### 연습 문제 15 : [뻐꾸기 해싱](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC%20%EC%9C%84%ED%95%9C%20%EC%9E%90%EB%A3%8C%20%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20with%20C%2B%2B/3%EC%9E%A5%20%ED%95%B4%EC%8B%9C%20%ED%85%8C%EC%9D%B4%EB%B8%94%EA%B3%BC%20%EB%B8%94%EB%A3%B8%20%ED%95%84%ED%84%B0/3.3%20%ED%95%B4%EC%8B%9C%20%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90%EC%84%9C%20%EC%B6%A9%EB%8F%8C/Cuckoo_Hashing.cpp)

### 실행 결과

```
Index : 0       1       2       3       4       5       6
Data1 : -1      -1      -1      -1      -1      -1      -1
Data2 : -1      -1      -1      -1      -1      -1      -1

1번 테이블에 10 삽입
1번 테이블에 20 삽입
1번 테이블에 30 삽입

1번 테이블에 104삽입 : 기존의 20 이동 -> 2번 테이블에 20 삽입
1번 테이블에 2삽입 : 기존의 30 이동 -> 2번 테이블에 30 삽입
1번 테이블에 70 삽입
1번 테이블에 9삽입 : 기존의 2 이동 -> 2번 테이블에 2 삽입
1번 테이블에 90삽입 : 기존의 104 이동 -> 2번 테이블에 104삽입 : 기존의 2 이동 -> 1번 테이블에 2삽입 : 기존의 9 이동 -> 2번 테이블에 9 삽입
1번 테이블에 2삽입 : 기존의 2 이동 -> 2번 테이블에 2삽입 : 기존의 104 이동 -> 1번 테이블에 104삽입 : 기존의 90 이동 -> 2번 테이블에 90 삽입
1번 테이블에 7삽입 : 기존의 70 이동 -> 2번 테이블에 70 삽입

Index : 0       1       2       3       4       5       6
Data1 : 7       -1      2       10      -1      -1      104
Data2 : 2       9       20      70      30      90      -1

1번 테이블에 14삽입 : 기존의 7 이동 -> 2번 테이블에 7삽입 : 기존의 9 이동 -> 1번 테이블에 9삽입 : 기존의 2 이동 -> 2번 테이블에 2삽입 : 기존의 2 이동 -> 1번 테이블에 2삽입 : 기존의 9 이동 -> 2번 테이블에 9삽입 : 기존의 7 이동 -> 1번 테이블에 7삽입 : 기존의 14 이동 -> 14 삽입 시 순환 발생! 재해싱이 필요합니다!
```

아래 그림이 뻐꾸기 해싱을 사용한 삽입, 검색, 삭제 연산의 도식도이다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/fe1bd838-3b2a-4970-84c2-465a6dc95bf9)

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/363f4b33-15b0-4118-8acd-da1930a486b8)

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/cf0e444d-35e1-4b5d-80ad-56bcf044d478)

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/5556cfc5-825b-4c08-80e8-14dac4666d3d)

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/38b3df4a-e818-49f5-b929-8d666266f059)
