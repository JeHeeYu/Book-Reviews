# 3.3 해시 테이블에서 충돌

### 3.3.1 체이닝(Chaining)
체이닝은 두 값을 모두 저장할 수 있는 여러 방법 중 하나이다.
<br>
이 방법은 해시 테이블의 특정 위치에 하나의 키를 저장하는 것이 아니라 하나의 연결 리스트를 저장한다.
<br>
<br>
그러므로 새로 삽입된 키에 의해 충돌이 발생하면 리스트의 맨 뒤에 새로운 키를 추가한다.
<br>
따라서 다수의 원소를 원하는 만큼 저장할 수 있다.
<br>
<br>
벡터 대신 연결 리스트를 사용하는 이유는 특정 위치의 원소를 빠르게 삭제하기 위함이다.
<br>

### 연습 문제 14 : [체이닝을 사용하는 해시 테이블](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC%20%EC%9C%84%ED%95%9C%20%EC%9E%90%EB%A3%8C%20%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20with%20C%2B%2B/3%EC%9E%A5%20%ED%95%B4%EC%8B%9C%20%ED%85%8C%EC%9D%B4%EB%B8%94%EA%B3%BC%20%EB%B8%94%EB%A3%B8%20%ED%95%84%ED%84%B0/3.3%20%ED%95%B4%EC%8B%9C%20%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90%EC%84%9C%20%EC%B6%A9%EB%8F%8C/hash_map_chaining.cpp)

<br>

### 실행 결과

```
2을(를) 삽입했습니다.
25을(를) 삽입했습니다.
10을(를) 삽입했습니다.
100을(를) 삽입했습니다.
55을(를) 삽입했습니다.
해시 맵에서 100을(를) 찾았습니다.
해시 맵에서 2을(를) 찾았습니다.
25을(를) 삭제했습니다.
```

이 예제에서는 리스트를 이용하여 다수의 값을 저장할 수 있기 때문에 갚을 덮어쓰는 현상이 발생하지 않는다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/293cee88-242c-4d7d-92ee-b4885679a971)

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/e92db9b7-cc86-4c36-ab27-d8379fa49190)

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/7b6f59a8-31ad-4787-914e-4f787a1135fb)

<br>

위 예제에서 특정 해시 값 위치에 하나의 원소만 저장되는 것이 아니라 여러 개의 원소가 리스트 형태로 저장된다.
<br>
<br>
시간 복잡도를 보면, 삽입 함수의 경우는 O(1)이다.
<br>
리스트에 노드를 추가하는 연산이 단순히 값을 설정하는 것보다는 조금 느릴 수 있지만, 심하게 느리지는 않다.
<br>
체이닝을 통해 얻을 수 있는 이점에 비하면 무시할 수 있는 수준이다.
<br>
<br>
다만 검색과 삭제는 데이터 크기와 해시 테이블 크기에 따라 상당히 느릴 수 있다.
<br>
<br>
예를 들어 모든 키가 같은 해시 값을 가질 경우, 검색 연산은 연결 리스트에서 선형 검색을 수행하는 것과 같으므로 O(N)의 시간 복잡도를 갖게 된다.
<br>
만약 해시 테이블이 저장할 키 개수에 비해 매우 작다면 충돌이 많이 발생하게 되고, 리스트는 평균적으로 더 길어진다.
<br>
<br>
반면에 너무 큰 해시 테이블을 가지고 있다면 실제 데이터는 듬성듬성 존재하게 되므로 메모리 낭비가 심해진다.
<br>
그러므로 응용 프로그램의 동작 시나리오를 고려해서 해시 테이블 크기를 적절하게 조절해야 한다.
<br>
<br>
이를 위해 하나의 수식을 정의할 수 있다.
```
부하율(Load Factor) : 해시 테이블에서 각각의 리시트에 저장되는 키의 평균 개수

부하율 = 전체 키 개수 / 해시 테이블 크기
```

만약 키 개수가 해시 테이블 크기와 같다면 부하율은 1이다.
<br>
이는 매우 이상적인 상태로, 모든 연산이 O(1)에 가깝게 작동하고 모든 메모리 공간을 적저라게 활용한다.
<br>
<br>
부하율이 1보다 작으면 리스트당 키가 하나도 저장되지 않은 경우가 있다는 뜻이고, 이는 메모리 낭비가 될 수 있다.
<br>
만약 부하율이 1보다 크면 이는 리스트의 평균 길이가 1보다 크다는 의미이고, 이 경우 검색, 삭제 등의 함수가 약간 느리게 동작할 수 있다.
<br>
<br>
부하율은 항상 O(1) 시간 복잡도로 계산할 수 있다.
<br>
몇몇 해시 테이블은 부하율이 1 근방의 특정 값보다 너무 크거나 작아지면 해시 함수를 변경하도록 구현되어 있으며, 이를 재해싱(Rehashing)이라고 한다.
<br>
<br>
즉, 해시 함수를 수정하여 부하율이 1에 가까운 값이 되도록 만드는 것이다.
<br>
변경된 해시 함수에 의한 값의 분포와 부하율을 고려하여 해시 테이블의 크기도 변경할 수 있다.
