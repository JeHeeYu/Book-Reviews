# 3.4 C++ 해시 테이블

C++ 에서 해시 값을 생성하는 용도로 std::hash<std::string>(std::string) 함수 객체를 제공한다.
<br>
이 함수 객체 내부에는 해시 함수 아고리즘이 구현되어 있다.
<br>
C++는 문자열 이외에도 모든 기본 데이터 타입에 대한 해시 값을 생성하는 기능도 제공한다.
<br>
<br>
이 해시 템플릿을 사용하면 모든 데이터 타입에 대해 사용할 수 있다.
<br>
STL은 이러한 기능을 std::unordered_set<Key>와 std::unordered_map<Key, Value> 형태로 미리 구현하여 제공한다.
<br>
std::unordered_set은 키만 저장할 수 있고, std::unordered_map은 키와 값을 함께 저장할 수 있다.
<br>
<br>
두 컨테이너 모두 체이닝을 사용하는 해시 테이블 형태로 구현되어 있다.
<br>
해시 테이블의 각 행은 키 또는 키와 값의 쌍을 저장하는 벡터이다.
<br>
<br>
여기서 각 행을 버킷(Bucket)이라고 부른다.
<br>
즉, 키로부터 해시 값을 구하면 이에 해당하는 버킷에 접근할 수 있다.
<br>
각 버킷은 하나의 리스트를 가진다.
<br>
<br>
기본적으로 이들 컨테이너는 최대 1의 부하율을 가진다.
<br>
해시 테이블 크기보다 원소 개수가 많아지게 되면 곧바로 해시 테이블 크기를 키우고, 해시 함수를 변경하는 재해싱이 일어난다.
<br>
그 결과 부하율은 1보다 작아지게 된다.
<br>
<br>
사용자가 강제로 rehash() 함수를 호출하여 재해싱을 할 수도 있다.
<br>
max_load_factor(float) 함수를 사용하여 기본값이 1로 되어 있는 부하율 최대 한계치를 변경할 수도 있다.
<br>
부하율이 지정된 최대 한계치를 넘어가면 재해싱이 발생한다.
<br>
<br>
std::unordered_set과 std::unordered_map 컨테이너는 검색, 삽입, 삭제 등의 보편적인 기능을 제공한다.
<br>
모든 원소에 차례대로 접근할 수 있도록 반복자 기능도 제공하고, 벡터나 배열 같은 다른 컨테이너로부터 곧바로 std::unordered_set 또는 set::unordered_map을 구성할 수 있는 생성자고 제공한다.
<br>
<br>
std::unordered_map은 [] 연산자를 이용하여 주어진 키에 해당하는 값을 받을 수도 있다.

<br>

### 연습 문제 16 : [STL에서 제공하는 해시 테이블](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC%20%EC%9C%84%ED%95%9C%20%EC%9E%90%EB%A3%8C%20%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20with%20C%2B%2B/3%EC%9E%A5%20%ED%95%B4%EC%8B%9C%20%ED%85%8C%EC%9D%B4%EB%B8%94%EA%B3%BC%20%EB%B8%94%EB%A3%B8%20%ED%95%84%ED%84%B0/3.4%20C%2B%2B%20%ED%95%B4%EC%8B%9C%20%ED%85%8C%EC%9D%B4%EB%B8%94/stl_hash_table.cpp)

### 실행 결과

```
*** std::unordered_set 예제 ***
set1 초깃값 : 5 4 3 2 1 
2 삽입 : 5 4 3 2 1 
10, 300 삽입 : 10 5 4 3 2 300 1 
4 검색 성공
100 검색 실패
2 삭제 : 10 5 4 3 300 1 
2 검색 실패
*** std::unordered_map 예제 ***
2, 3의 제곱 삽입 : 3 -> 9, 2 -> 4, 
20, 30의 제곱 삽입 : 20 -> 400, 3 -> 900, 2 -> 4, 
10 검색 실패
20검색 성공 값 = 400
squareMap[3] = 900
squareMap[100] = 0
100 -> 0, 20 -> 400, 3 -> 900, 2 -> 4,
```

위 예제에서 squareMap에 100을 삽입한 적이 없음에도 squareMap[100] = 이 출력된 것을 볼 수 있다.
<br>
이는 [] 연산자가 실제 값이 없을 때는 기본값 0을 추가한 후 반환하기 때문이다.
<br>
<br>
만약 현재 버킷의 개수를 알고 싶다면 bucket_count() 함수를 사욯알 수 있다.
<br>
이외에도 load_factor(), max_bucket_count() 등의 함수를 이용하여 컨테이너 내부에서 사용되는 설정 값을 알 수 있다.
<br>
또한 rehash() 함수를 이용하여 수동으로 재해싱을 수행할 수 있다.
<br>
<br>
이들 컨테이너는 체이닝 기법을 사용하여 구현되었으므로 키와 값의 쌍을 서로 다른 버킷에 저장한다.
<br>
그러므로 버킷에서 특정 키를 찾을 때 키가 같은지를 비교해야 한다.
<br>
그러므로 키 타입에 대해 등호 연산이 정의되어 있어야 한다.
<br>
또는 템플릿 매개변수로 비교자를 지정할 수 있다.
<br>
<br>
STL은 C++에서 지원하는 모든 기본 데이터 타입에 대한 해시 함수를 제공하낟.
<br>
따라서 컨테이너에서 사용자 정의 클래스 또는 구조체를 키 타입으로 사용하려면 std 네임스페이스 안에서 해시 함수를 구현해야 한다.
<br>
<br>
또는 컨테이너의 템플릿 매개변수로 해시 함수 객체를 지정할 수도 있다.
