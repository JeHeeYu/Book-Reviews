# 3.2 해시 테이블

해시 테이블 에로, 옥스퍼드 영어 사전에는 약 170,000개의 단어가 수록되어 있다.
<br>
여기서 선형 검색으로 검색할 경우 O(N)의 시간을 필요로 한다.
<br>
<br>
더 나은 방법으로는 BST와 같은 속성을 갖도록 높이 균형 트리에 데이터를 저장하는 것이다.
<br>
이렇게 사용할 경우 시간 복잡도가 O(log N)이 되기 때문에 선형 검색보다 훨씬 빨라진다.
<br>
<br>
그러나 검색 횟수가 크게 증가할 경우 이 정도 연산 속도도 만족스럽지 않을 수 있다.
<br>
이러한 상황에서는 더욱 효율적인 방법이 필요하고, 그 중 해시 테이블(Hash Table)이 좋은 방법 중 하나이다.
<br>
<br>
해시 테이블의 핵심은 해싱(Hashing)이다.
<br>
해싱은 각각의 데이터를 가급적 고유한 숫자 값으로 표현하고, 나중에 같은 숫자값을 사용하여 데이터의 유무를 확인하거나 또는 해당 숫자에 대응하는 원본 데이터를 추출하는 작업이다.
<br>
<br>
주어진 데이터로부터 고유한 숫자 값을 계산하는 함수를 해시 함수(Hash Function)이라고 한다.

<br>

### 해싱(Hashing)
해싱에 대해 한가지 예로, 정수를 저장하는 컨테이너가 있고 이 컨테이너에 특정 정수가 들어 있는지를 빠르게 판단하고 싶다고 가정한다.
<br>
가장 간단한 방법은 부울 타입 배열을 하나 만들고 입력 정수를 이 배열 원소의 인덱스로 취급하는 것이다.
<br>
<br>
만약 새 원소를 삽입한다면 해당 인덱스의 배열 값을 1로 설정한다.
<br>
즉, 새 원소 x를 삽입하 경우 data[x] = true로 설정한다.
<br>
특정 정수 x가 있는지를 알고 싶다면 단순히 data[x] 값이 true인지를 확인하면 된다.
<br>
<br>
이런 방식을 사용할 경우, 원소 삽입, 삭제, 검색의 시간 복잡도는 O(1)이다.
<br>
아래는 0부터 9사이의 정수를 저장하는 용도의 간단한 해시 테이블이다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/4c62b396-7e36-4816-9fa2-a02d4e6c1352)

<br>

그러나 위와 같은 방법은 다음과 같은 경우에 문제가 발생할 수 있다.
- 데이터가 실수인 경우
- 데이터가 숫자가 아닌 경우
- 데이터 범위가 너무 큰 경우(예를 들어 10억 개의 숫자를 사용한다면 10억 크기의 부울 타입 배열이 필요하므로 좋은 방법이 아님)

<br>

이 문제를 해결하기 위해 어떤 데이터 타입의 값이든 원하는 범위의 정수로 매핑하는 함수를 만들어 사용할 수 있다.
<br>
이러한 역할을 하는 함수가 해시 함수이다.
<br>
이 해시 함수는 데이터 원소를 인자로 받고 정해진 범위의 정수를 반환한다.
<br>
<br>
가장 간단한 해시 함수는 큰 범위의 정수를 인자로 받아 정해진 정수(n)로 나눈 나머지를 반환하는 모듈로 함수(Modulo Function)이며, 보통 % 기호로 표시한다.
<br>
이 경우 크기 n인 배열을 사용할 수 있다.
<br>
<br>
만약 이 함수에 숫자 x를 입력으로 주면 (x % n) 연산의 결과가 반환되고, 이 값은 0부터 (n - 1) 사이의 정수이다.
<br>
그럼 x를 배열에서 (x % n) 위치에 삽입하면 된다.
<br>
이처럼 해시 함수에 의해 반환되는 숫자 값을 해시 값(Hash Value)이라고 한다.
<br>
<br>
모듈로 함수의 문제점은 이 함수가 서로 다른 데이터에 대해 같은 해시 값을 반환할 수 있다는 점이다.
<br>
예를 들어 (9 % 7)과 (16 % 7)은 모두 해시 값으로 2를 반환한다.
<br>
<br>
그러므로 해시 값 2에 해당하는 위치가 true(또는 1)로 채워져 있을 경우, 여기에 들어 있는 데이터가 9인지 혹은 16인지 알 수 없다.
