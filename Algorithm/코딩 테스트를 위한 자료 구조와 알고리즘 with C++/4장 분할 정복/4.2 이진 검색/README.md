# 이진 검색

일반적인 검색을 예로, 정렬되어 있는 정수 시퀀스가 있으며 여기에 숫자 N이 있는지 확인하려고 한다.
<br>
이러한 검색은 일상생활에서도 자주 보인다.
<br>
<br>
예를 들어 고객 ID 순서로 정렬된 파일 목록에서 특정 고객 ID의 파일을 찾는다거나 학생 등록부에서 학생들의 시험 점수를 확인하는 등의 문제가 검색과 관련이 있다.
<br>
<br>
이러한 검색 문제는 두 가지 방법으로 접근할 수 있다.
<br>
첫번 째 방법은 시퀀스 전체 원소를 방문하면서 해당 원소가 N과 같은지 확인하는 것이다.
<br>
이러한 방법을 선형 검색(Linear Search)라고 하며 다음과 같이 구현할 수 있다.

```
bool linear_search(int N, std::vector<int>& sequence)
{
    for(auto i : sequence)
    {
        if(i == N)
            return true; // 찾음!
    }

    return false;
}
```

이 방법의 장점은 입력 시퀀스의 정렬 여부와 상관없이 항상 잘 동작한다.
<br>
그러나 이 방법은 효율적이지 않으며, 주어진 배열이 정렬되어 있다는 점을 이용하지 못한다.
<br>
<br>
선형 검색 알고리즘의 시간 복잡도는 O(N)이다.
<br>
주어진 시퀀스가 정렬되어 있다는 사실을 이용하는 검색 방법은 다음과 같다.

1. 전체 시퀀스 범위를 range로 설정
2. 현재 range의 가운데 원소를 M이라고 하고, M과 N을 비교
3. 만약 M = N이면 시퀀스에서 N을 찾은 것이므로 검색 중단
4. 그렇지 않으면 아래 두 규칙에 따라 range 수정
- 만약 N < M이면 N은 M의 왼쪽에 있을 것으로 예상할 수 있고, range에서 N 오른쪽에 있는 모든 원소 제거
- 만약 N > M이면 range에서 M 왼쪽에 있는 모든 원소 제거
5. 만약 range에 한 개보다 많은 원소가 남아 있다면 2단계로 이동
6. 그렇지 않으면 주어진 시퀀스에 N이 존재하지 않는 것이므로 검색 종료

아래 그림은 1부터 9까지의 정수가 차례대로 증가하는 시퀀스 S에서 N = 2를 찾는 이진 검색 동작을 나타낸 것이다.
<br>
<br>
1. 먼저 S의 모든 원소를 range로 간주하고, range에서 가운데 원소는 5이므로 N과 5를 비교
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/c8d54702-0449-42db-acd6-618417f1954d)

<br>

2. N < 5 이므로 N이 시퀀스에 있다면 5 왼쪽에 있음. 그러므로 입력 시퀀스에서 원소 5보다 오른쪽에 있는 원소들은 검색에서 고려하지 않아도 되므로 검색 범위 range를 1에서 5사이로 설정. 이때 가운데 원소는 3이 되며, 이제 N과 3을 비교

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/003cff24-46a9-4c9a-8b83-9c861246019b)

<br>

3. 현재 범위의 가운데 원소 3이 N보다 크므로, 시퀀스 시작 위치부터 원소 3이 있는 위치까지 새로운 range를 설정하면, 가운데 원소가가 2가 되며 이는 N과 같으므로 검색 종료

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/a6aa42ac-7ca1-431f-bfec-10e19346cb68)


<br>
