# 이진 검색

일반적인 검색을 예로, 정렬되어 있는 정수 시퀀스가 있으며 여기에 숫자 N이 있는지 확인하려고 한다.
<br>
이러한 검색은 일상생활에서도 자주 보인다.
<br>
<br>
예를 들어 고객 ID 순서로 정렬된 파일 목록에서 특정 고객 ID의 파일을 찾는다거나 학생 등록부에서 학생들의 시험 점수를 확인하는 등의 문제가 검색과 관련이 있다.
<br>
<br>
이러한 검색 문제는 두 가지 방법으로 접근할 수 있다.
<br>
첫번 째 방법은 시퀀스 전체 원소를 방문하면서 해당 원소가 N과 같은지 확인하는 것이다.
<br>
이러한 방법을 선형 검색(Linear Search)라고 하며 다음과 같이 구현할 수 있다.

```
bool linear_search(int N, std::vector<int>& sequence)
{
    for(auto i : sequence)
    {
        if(i == N)
            return true; // 찾음!
    }

    return false;
}
```

이 방법의 장점은 입력 시퀀스의 정렬 여부와 상관없이 항상 잘 동작한다.
<br>
그러나 이 방법은 효율적이지 않으며, 주어진 배열이 정렬되어 있다는 점을 이용하지 못한다.
<br>
<br>
선형 검색 알고리즘의 시간 복잡도는 O(N)이다.
<br>
주어진 시퀀스가 정렬되어 있다는 사실을 이용하는 검색 방법은 다음과 같다.

1. 전체 시퀀스 범위를 range로 설정
2. 현재 range의 가운데 원소를 M이라고 하고, M과 N을 비교
3. 만약 M = N이면 시퀀스에서 N을 찾은 것이므로 검색 중단
4. 그렇지 않으면 아래 두 규칙에 따라 range 수정
- 만약 N < M이면 N은 M의 왼쪽에 있을 것으로 예상할 수 있고, range에서 N 오른쪽에 있는 모든 원소 제거
- 만약 N > M이면 range에서 M 왼쪽에 있는 모든 원소 제거
5. 만약 range에 한 개보다 많은 원소가 남아 있다면 2단계로 이동
6. 그렇지 않으면 주어진 시퀀스에 N이 존재하지 않는 것이므로 검색 종료

아래 그림은 1부터 9까지의 정수가 차례대로 증가하는 시퀀스 S에서 N = 2를 찾는 이진 검색 동작을 나타낸 것이다.
<br>
<br>
1. 먼저 S의 모든 원소를 range로 간주하고, range에서 가운데 원소는 5이므로 N과 5를 비교
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/c8d54702-0449-42db-acd6-618417f1954d)

<br>

2. N < 5 이므로 N이 시퀀스에 있다면 5 왼쪽에 있음. 그러므로 입력 시퀀스에서 원소 5보다 오른쪽에 있는 원소들은 검색에서 고려하지 않아도 되므로 검색 범위 range를 1에서 5사이로 설정. 이때 가운데 원소는 3이 되며, 이제 N과 3을 비교

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/003cff24-46a9-4c9a-8b83-9c861246019b)

<br>

3. 현재 범위의 가운데 원소 3이 N보다 크므로, 시퀀스 시작 위치부터 원소 3이 있는 위치까지 새로운 range를 설정하면, 가운데 원소가가 2가 되며 이는 N과 같으므로 검색 종료

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/a6aa42ac-7ca1-431f-bfec-10e19346cb68)


<br>


### 연습 문제 18 : [이진 검색 구현 및 성능 평가](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC%20%EC%9C%84%ED%95%9C%20%EC%9E%90%EB%A3%8C%20%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20with%20C%2B%2B/4%EC%9E%A5%20%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5/4.2%20%EC%9D%B4%EC%A7%84%20%EA%B2%80%EC%83%89/binary_search.cpp)

### 실행 결과

```
선형 검색으로 원소를 찾았습니다!
이진 검색으로 원소를 찾았습니다!
이진 검색 수행 시간: 1
원소를 찾았습니다.
이진 검색 수행 시간: 2
원소를 찾지 못했습니다.
이진 검색 수행 시간: 3
원소를 찾았습니다.
```

실행 결과와 같이 입력 벡터 크기가 크게 증가했음에도 이진 검색 수행 시간의 거의 바뀌지 않은 것을 알 수 있다.
<br>
앞선 이진 검색 구현에서는 std::distance()와 std::advance() 함수 같은 C++ 표준 라이브러리 함수와 반복자를 사용했다.
<br>
이러한 코딩 방식은 데이터 타입에 영향을 받지 않으면서 부정확한 배열 인덱스 사용 위험이 줄어들기 때문에 모던 C++에서 권장하는 방법이다.
<br>
<br>
이번에는 예제로 부동소수점 숫자로 구성된 벡터를 검색하려고 한다.
<br>
연습 문제 18에서 간단하게 다음과 같은 형태로 함수 원형을 변경하면 된다.
```
bool linear_search(float N, std::vector<float>& S)
bool binary_search(float N, std::vector<float>& S)
```
이 두 함수의 내부 코드는 컨테이너의 동작에만 관여하고 실제 데이터 타입과는 무관하기 때문에 변경하지 않고 그대로 놔두어도 괜찮다.
<br>
이처럼 알고리즘에서 사용하는 데이터 타입과 알고리즘 로직을 분리하는 것이 모던 C++에서 재사용 가능한 코드를 작성하는 기본 방침이다.
