# 분할 정복


## 4.3 분할 정복(Divide and Conquer) 이해하기
분할 정복 접근 방법의 핵심 이론은 매우 단순하고 직관적이다.
<br>
주어진 문제의 규모가 커서 한 번에 해결하기 어렵다면 이를 작은 부분 문제로 나누어 해결하는 방식이다.
<br>
<br>
부분 문제로 나누는 작업을 반복하여 그 해답을 찾고, 다시 그 해답을 합쳐서 다음 문제에 대한 해답을 유도하는 것이다.
<br>
주어진 문제를 분할 정복 방법으로 해결하려면 다음과 같은 세 단계가 필요하다.
1. 분할(Divide) : 주어진 문제를 동일한 방식으로 해결할 수 있는 여러 부분 문제로 나눔
2. 정복(Conquer) : 각 부분 문제에 대한 해답을 구함
3. 결합(Combine) : 각 부분 문제의 해답을 결합하여 전체 문제에 대한 해답을 구함

<br>

## 4.4 분할 정복을 이용한 정렬 알고리즘

정렬 알고리즘 구현에 있어 필요한 요구 사하은 다음과 같다.
- 모든 데이터 타입에 동작해야 함(정수, 실수, C++ 구조체 또는 클래스 멤버 등)
- 많은 양의 데이터를 처리할 수 있어야 함(컴퓨터의 메인 메모리보다 큰 용량에 대해서도 동작해야 함)
- 정렬 알고리즘은 시간 복잡도 측면이나 실제 동작 시 빠르게 동작해야 함

나열된 세 가지 조건을 모두 만족하면 바람직하지만, 현실적으로 두 번째와 세 번째 요구 사항을 동시에 만족하기는 어렵다.
<br>
두 번째 요구 사항은 외부 정렬(External Sorting), 즉 컴퓨터의 메인 메모리에 데이터가 상주하지 않은 상태에서 수행되는 정렬을 필요로 한다.
<br>
외부 정렬 알고리즘은 실행 중 임의 시점에서 전체 데이터의 일부만을 메모리에 올려놓고 동작할 수 있다.

<br>

### 4.4.1 병합 정렬(Merge Sort)
병합 정렬은 많은 원소로 구성된 전체 집합을 작은 크기의 부분집합으로 나눠 각각을 정렬하고, 정렬된 부분집합을 오름차순 또는 내림차순 순서를 유지하면서 합치는 방식을 말한다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/a2bfe7b4-cac2-44e8-9eba-aadfb6393391)

<br>

위 그림은 병합 정렬을 사용하여 정수 배열을 정렬하는 예를 보여준다.
<br>
이 알고리즘은 전체 배열을 여러 개의 부분 배열로 나누는 작업을 반복하며, 이 작업은 각 부분 배열이 하나의 원소만 가질 때 멈춘다.
<br>
<br>
이후에는 다시 배열을 합치는 작업을 반복하며, 이때 합쳐진 원소 순서가 오름차순을 유지하도록 조정한다.

<br>

### 연습 문제 19 : [병합 정렬](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC%20%EC%9C%84%ED%95%9C%20%EC%9E%90%EB%A3%8C%20%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20with%20C%2B%2B/4%EC%9E%A5%20%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5/4.3%20~%204.4%20%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5/merge_sort.cpp)

<br>

### 실행 결과

```
정렬되지 않은 입력 벡터
45 1 3 1 2 3 45 5 1 2 44 5 7 
45.6 1 3.8 1.01 2.2 3.9 45.3 5.5 1 2 44 5 7 
45.6 1 3.8 1.01 2.2 3.9 45.3 5.5 1 2 44 5 7 
b z a e f t q u y 

병합 정렬에 의해 정렬된 벡터
1 1 1 2 2 3 3 5 5 7 44 45 45 
1 1 1.01 2 2.2 3.8 3.9 5 5.5 7 44 45.3 45.6 
1 1 1.01 2 2.2 3.8 3.9 5 5.5 7 44 45.3 45.6 
a b e f q t u y z
```
