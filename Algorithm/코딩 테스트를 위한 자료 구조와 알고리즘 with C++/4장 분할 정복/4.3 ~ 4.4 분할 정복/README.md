# 분할 정복


## 4.3 분할 정복(Divide and Conquer) 이해하기
분할 정복 접근 방법의 핵심 이론은 매우 단순하고 직관적이다.
<br>
주어진 문제의 규모가 커서 한 번에 해결하기 어렵다면 이를 작은 부분 문제로 나누어 해결하는 방식이다.
<br>
<br>
부분 문제로 나누는 작업을 반복하여 그 해답을 찾고, 다시 그 해답을 합쳐서 다음 문제에 대한 해답을 유도하는 것이다.
<br>
주어진 문제를 분할 정복 방법으로 해결하려면 다음과 같은 세 단계가 필요하다.
1. 분할(Divide) : 주어진 문제를 동일한 방식으로 해결할 수 있는 여러 부분 문제로 나눔
2. 정복(Conquer) : 각 부분 문제에 대한 해답을 구함
3. 결합(Combine) : 각 부분 문제의 해답을 결합하여 전체 문제에 대한 해답을 구함

<br>

## 4.4 분할 정복을 이용한 정렬 알고리즘

정렬 알고리즘 구현에 있어 필요한 요구 사하은 다음과 같다.
- 모든 데이터 타입에 동작해야 함(정수, 실수, C++ 구조체 또는 클래스 멤버 등)
- 많은 양의 데이터를 처리할 수 있어야 함(컴퓨터의 메인 메모리보다 큰 용량에 대해서도 동작해야 함)
- 정렬 알고리즘은 시간 복잡도 측면이나 실제 동작 시 빠르게 동작해야 함

나열된 세 가지 조건을 모두 만족하면 바람직하지만, 현실적으로 두 번째와 세 번째 요구 사항을 동시에 만족하기는 어렵다.
<br>
두 번째 요구 사항은 외부 정렬(External Sorting), 즉 컴퓨터의 메인 메모리에 데이터가 상주하지 않은 상태에서 수행되는 정렬을 필요로 한다.
<br>
외부 정렬 알고리즘은 실행 중 임의 시점에서 전체 데이터의 일부만을 메모리에 올려놓고 동작할 수 있다.

<br>

### 4.4.1 병합 정렬(Merge Sort)
병합 정렬은 많은 원소로 구성된 전체 집합을 작은 크기의 부분집합으로 나눠 각각을 정렬하고, 정렬된 부분집합을 오름차순 또는 내림차순 순서를 유지하면서 합치는 방식을 말한다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/a2bfe7b4-cac2-44e8-9eba-aadfb6393391)

<br>

위 그림은 병합 정렬을 사용하여 정수 배열을 정렬하는 예를 보여준다.
<br>
이 알고리즘은 전체 배열을 여러 개의 부분 배열로 나누는 작업을 반복하며, 이 작업은 각 부분 배열이 하나의 원소만 가질 때 멈춘다.
<br>
<br>
이후에는 다시 배열을 합치는 작업을 반복하며, 이때 합쳐진 원소 순서가 오름차순을 유지하도록 조정한다.

<br>

### 연습 문제 19 : [병합 정렬](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC%20%EC%9C%84%ED%95%9C%20%EC%9E%90%EB%A3%8C%20%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20with%20C%2B%2B/4%EC%9E%A5%20%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5/4.3%20~%204.4%20%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5/merge_sort.cpp)

<br>

### 실행 결과

```
정렬되지 않은 입력 벡터
45 1 3 1 2 3 45 5 1 2 44 5 7 
45.6 1 3.8 1.01 2.2 3.9 45.3 5.5 1 2 44 5 7 
45.6 1 3.8 1.01 2.2 3.9 45.3 5.5 1 2 44 5 7 
b z a e f t q u y 

병합 정렬에 의해 정렬된 벡터
1 1 1 2 2 3 3 5 5 7 44 45 45 
1 1 1.01 2 2.2 3.8 3.9 5 5.5 7 44 45.3 45.6 
1 1 1.01 2 2.2 3.8 3.9 5 5.5 7 44 45.3 45.6 
a b e f q t u y z
```

<br>

### 4.4.3 퀵 정렬(Quick Sort)
병합 정렬의 목적이 대용량의 데이터를 정렬하는 것이라면, 퀵 정렬은 평균 실행 시간을 줄이는 것이 목표이다.
<br>
퀵 정렬의 기본 아이디어는 병합 정렬과 같다.
<br>
<br>
즉, 원본 입력 배열을 작은 크기의 부분 배열로 나누고, 각 부분 배열을 정렬한 후, 그 결과를 합쳐서 전체 정렬된 배열을 생성한다.
<br>
다만 퀵 정렬의 핵심 연산은 병합이 아니라 분할이다.
<br>

### 퀵 정렬의 분할 연산 방법
입력 배열이 주어지고 입력 배열 중 피벗(Pivot) 원소 P를 선택했을 경우, 퀵 정렬을 위한 분할 연산은 다음 두단계를 통해 이루어진다.
1. 입력 배열을 두 개의 부분 배열 L과 R로 나눔. L은 입력 배열에서 P보다 작거나 같은 원소를 포함하는 부분 배열, R은 입력 배열에서 P보다 큰 원소를 포함하는 부분 배열임
2. 입력 배열을 L, P, R 순서로 재구성

아래 그림은 정렬되지 않은 배열에서 첫 번째 웟노를 피벗으로 선택하여 분할 연산을 적용한 결과이다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/3eb33804-8557-4210-bb0b-368dde57d52e)

<br>

이러한 방식으로 분할 연산을 수행하면 피벗 P는 배열이 최종적으로 정렬되었을 때 P가 실제로 있어야 하는 위치로 이동하게 된다.
<br>
예를 들어 위 그림의 경우, 피벗 원소 5가 분할 연산 후 배열의 다섯 번째 위치로 이동했다.
<br>
이는 배열 전체를 오름차순으로 정렬했을 경우, 원소 5가 있어야 하는 위치와 같다.
<br>
<br>
이러한 특징은 퀵 정렬 알고리즘의 핵심 아이디어이며, 전체 퀵 정렬 알고리즘은 다음과 같다.
1. 입력 배열 A가 두 개 이상의 원소를 가지고 있다면 A에 분할 연산을 수행함. 그러면 부분 배열 L과 R이 생성됨
2. 1단계의 입력으로 L을 사용
3. 1단계의 입력으로 R을 사용

여기서 2단계와 3단계는 분할 연산에 의해 생성된 부분 배열에 재귀적으로 적용된다.
<br>
이러한 분할 연산을 재귀적으로 반복할 수 있도록 모든 원소가 차츰 오름차순으로 정렬된다.
<br>
<br>
퀵 정렬 재귀 트리(Recusion Tree)는 빠르게 깊은 형태로 구성될 수 있으며, 여섯 개의 원소로 이루어진 배열 { 5, 6, 7, 3, 1, 9 }에 퀵 정렬을 적용한 예가 아래 그림이다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/c6bd04fd-a53e-4460-a9f5-5360d1612967)

<br>

위 그림은 이전 단게에서 분할된 부분 배열에 대해 서로 선택한 피벗을 이용하여 분할 연산이 반복적으로 적용되는 것을 보여준다.
<br>
이 예제에서는 배열의 첫 번째 원소를 피벗으로 선택하여 사용했다.
<br>
입력 배열이 어떤 순서로 되어 있는지를 알 수 없기 때문에 임의의 원소를 피벗으로 선택하여 사용해도 된다.

<br>

### 연습 문제 20 : [퀵 정렬](https://github.com/JeHeeYu/Book-Reviews/blob/main/Algorithm/%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC%20%EC%9C%84%ED%95%9C%20%EC%9E%90%EB%A3%8C%20%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20with%20C%2B%2B/4%EC%9E%A5%20%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5/4.3%20~%204.4%20%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5/quick_sort.cpp)

<br>

### 실행 결과
```
정렬되지 않은 입력 벡터
45 1 3 1 2 3 45 5 1 2 44 5 7 
45.6 1 3.8 1.01 2.2 3.9 45.3 5.5 1 2 44 5 7 
45.6 1 3.8 1.01 2.2 3.9 45.3 5.5 1 2 44 5 7 
b z a e f t q u y 

퀵 정렬 수행 후의 벡터
1 1 1 2 2 3 3 5 5 7 44 45 45 
1 1 1.01 2 2.2 3.8 3.9 5 5.5 7 44 45.3 45.6 
1 1 1.01 2 2.2 3.8 3.9 5 5.5 7 44 45.3 45.6 
a b e f q t u y z 
```
