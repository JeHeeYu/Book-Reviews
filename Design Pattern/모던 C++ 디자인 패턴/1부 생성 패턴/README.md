# 생성 패턴 정리

## 객체 생성 방법

### 스택(Stack) 할당
스택 메모리를 할당받아 객체를 생성하는 것을 말한다.
<br>
이러한 객체는 스코프를 벗어날 때 자동으로 소멸된다. ( { }와 같은 스코프)
<br>
<br>
명시적으로 객체를 소멸시키지 않는다면 객체가 대입된 변수가 스코프에서 벗어나는 마지막 순간에 해당 객체의 소멸자가 호출된다.

<br>

### 힙(Heap) 할당
원시 포인터를 이용하여 Foo* foo = new Foo와 같이 개게를 생성하면 힙 메모리에 객체가 할당된다.
<br>
이렇게 인스턴스를 생성하면 사용 후 메모리 해제를 비롯한 뒷정리를 누가 할 것인지가 불분명한 문제가 생긴다.

<br>

### unique 포인터(unique_ptr)
'독점' 포인터라고도 한다.
<br>
이 스마트 포인터는 힙에 할당된 포인터를 받아 더 이상 참조하는 곳이 없을 때 자동으로 소멸 작업이 이루어지도록 관리해준다.
<br>
<br>
unique 포인터는 '독점' 이라는 이름이 의미하듯 복제할 수 없고 다른 함수에 넘겨줄 수도 없다.
<br>
단, 원본과 그 제어권까지 통째로 이양하는 것은 가능하다.

<br>

### shared 포인터(shared_ptr)
'공유' 포인터라고도 한다.
<br>
이 스마트 포인터는 힙에 할당된 포인터를 받아 코드 안의 다른 곳과 포인터를 공유하고 그 어느 부분에서도 더 이상 참조하는 곳이 없을 때 자동으로 소멸되도록 관리해준다.

<br>

### 약한 포인터(weak_ptr)
'간접' 포인터라고도 한다.
<br>
이 포인터는 소유 개념이 없고, shared_ptr에 의해 관리되는 포인터를 간접적으로 참조한다.
<br>
<br>
실제 객체에 참조를 할 때는 shared_ptr로 변환해야만 한다.
<br>
이 포인터는 shared_ptr 간에 순환 참조가 일어나는 것을 막기 위해 사용된다.

## 함수에서의 객체 리턴
워드(2 Byte) 크기보다 큰 값을 함수에서 리턴하는 방법에는 여러 가지 방법이 있다.
<br>
그중 가장 쉬운 방법은 아래와 같은 방법이다.

```
Foo make_foo(int n)
{
    return Foo{n};
}
```

이런 방법은 Foo 전체를 복제하는 오버헤드가 따른다.
<br>
항상 그렇지는 않은데, 예를 들어 아래와 같은 Foo 클래스가 있다.

```
struct Foo
{
    Foo(int n) { }
    Food(const Foo&) { cout << "COPY CONSTRUCTOR!!!\n"); }
};
```

이 경우 복제 생성자가 한 번도 안 불릴수도 있고 두 번까지 불릴 수도 있다.
<br>
정확한 횟수는 컴파일러에 달려 있다.
<br>
<br>
컴파일러는 리턴 값 최적화 기능(RVO, Return Value Optimization)을 가지고 있기 때문에 추가적인 복제가 일어나는 것을 막는다.
<br>
하지만 복잡한 시나리오에서는 RVO에 의존할 수 없다.
<br>
<br>
또 다른 접근 방법은 unique_ptr와 같은 스마트 포인터를 리턴하는 것이다.

```
unique_ptr<Foo> make_foo(Int n)
{
    return make_unique<Foo>(n);
}
```
이 방법은 매우 안전하나, 논란이 있다.
<br>
어떤 사용자는 스마트 포인터를 싫어 할 수 있는데, 사용하면 사용자에게 스마트 포인터 사용을 강제하게 된다.
<br>
<br>
또는 스마트 포인터를 사용하기는 하지만 shared_ptr를 사용하고 싶어 할 수도 있다.
<br>
<br>
마지막 방법은 원시 포인터를 리턴하는 것이며 ower<T>도 같이 적용할 수 있다.
<br>
이렇게 하면 할당된 객체의 소멸을 강제하지 않으면서도 객체를 정리할 책임이 호출자에 있음을 명확히 할 수 있다.

```
onwer<Foo*> make_foo(int n)
{
    return new Foo(n);
}
```

이러한 방법은 함수의 사용자에게 힌트를 주는 것으로 볼 수 있다.
<br>
즉 포인터를 리턴할 테니 관리는 전역적으로 리턴받는 쪽의 책임을 알려준다.
<br>
<br>
결론적으로 여러 가지 방법이 있으며 모두 각각 의미가 있으므로 어느 것이 더 좋다고는 말 할수 없다.
