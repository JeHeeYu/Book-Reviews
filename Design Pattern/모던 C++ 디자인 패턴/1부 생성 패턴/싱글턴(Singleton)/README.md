# 싱글턴 패턴 정리 내용

## 싱글턴(Singleton) 패턴
싱글턴 패턴은 클래스에 인스턴스가 하나만 있도록 하면서 이 인스턴스에 대한 전역 접근을 허용하는 생성 디자인 패턴이다.
<br>
<br>
싱글턴 패턴은 디자인 패턴의 역사상 가장 많은 미움을 받고 있는 디자인 패턴이다.
<br>
하지만 상황에 따라 싱글턴 패턴을 필요로 하는 상황이 있다.
<br>
<br>
싱글턴 디자인 패턴은 어떤 특정 컴포넌트의 인스턴스가 애플리케이션 전체에서 단 하나만 존재해야 하는 상황을 처리하기 위해 고안되었다.
<br>
<br>
예를 들어 메모리에 데이터베이스를 로딩하고 읽기 전용 인터페이스를 제공하는 경우는 싱글턴 패턴을 활용하기 딱 좋은 상황이다.
<br>
왜냐하면 동일한 데이터를 여러번 로딩하여 메모리를 낭비할 필요가 없기 때문이다.
<br>
어쩌면 애당초 두 개 이상의 데이터베이스가 올라갈 만큼의 메모리가 크지 않을 수도 있고, 또는 메모리에 여유가 없으면 프로그램이 이상 동작을 할 수도 있다.

<br>

## 전역 객체로서의 싱글턴
이 문제의 대한 손쉬운 접근 방법은 객체를 단 한번만 인스턴스화하도록 약속하는 것이다.
<br>
예를 들어 아래와 같은 코드가 있다.

```
struct Database
{
    // 이 객체를 두 개 이상 인스턴스화 하지 말 것
    Database();
};
```

이렇게 약속으로 한다면 어떤 개발자는 이 주석을 무시하고 사용하는 경우 말고도, 눈에 보이지지도, 의도하지도 않은 은밀한 방식으로 생성자가 호출되어 버릴 수도 있다.
<br>
복제 생성자, 복제 대입 연산자에 의한 것일 수도 있고, make_unique()의 호출, 또는 제어 역전(IoC) 컨테이너의 사용에 따른 것일 수도 있다.
<br>
<br>
이를 극복하는 방법으로 가장 간단하게 static 전역 객체를 두는 것이다.

```
static Database database();
```

static 전역 객체의 문제점은 각각의 컴파일 단위 바이너리들에서 초기화 순서가 정의되어 있지 않다는 것이다.
<br>
이 부분은 까다로운 문제를 일으킨다.
<br>
<br>
static 전역 객체가 여러 개 사용된다면 어느 한 모듈에서 전역 객체를 참조할 때 그 전역 객체가 참조하는 또 다른 전역 객체가 아직 초기화된 상태가 아닐 수 있다.
<br>
그리고 사용자가 전역 객체가 있다는 사실을 어떻게 알 수 있느냐 하는 문제도 존재한다.
<br>
<br>
사용자가 조금 더 알기 쉽도록, 필요한 객체를 리턴하는 전역 함수를 제공하는 방법이 있다.

```
Database& get_database()
{
    static Database database;
    
    return database;
}
```

이 함수를 호출하면 데이터베이스에 접근할 수 있는 참조를 얻을 수 있다.
<br>
하지만 위 함수의 스레드 안전성이 C++ 11 이상 버전에서만 안전이 보장된다는 점에 유의해야 한다.
<br>
<br>
static 객체를 초기화하는 코드 앞뒤로 컴파일러가 락을 삽입하여 초기화 와중에 동시에 다른 스레드에서 접근하는 것을 방지해 주는지 확인해야 한다.
<br>
<br>
물론 이 방식도 문제가 생길 수 있다.
<br>
만약 데이터베이스의 소멸자에서 다른 싱글턴 모듈을 참조한다면 프로그램이 Crash가 발생할 가능성이 높다.
<br>

## 전통적인 구현 방법

 































